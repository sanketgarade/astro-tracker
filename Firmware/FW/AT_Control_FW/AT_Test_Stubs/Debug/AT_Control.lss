
AT_Control.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000cb8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000004  00800060  00000cb8  00000d4c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000052  00800064  00800064  00000d50  2**0
                  ALLOC
  3 .stab         000006cc  00000000  00000000  00000d50  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000085  00000000  00000000  0000141c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000060  00000000  00000000  000014a1  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000331  00000000  00000000  00001501  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000092d  00000000  00000000  00001832  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000025c  00000000  00000000  0000215f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000bc0  00000000  00000000  000023bb  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000120  00000000  00000000  00002f7c  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000004cb  00000000  00000000  0000309c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubtypes 000000b4  00000000  00000000  00003567  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 f1 05 	jmp	0xbe2	; 0xbe2 <__vector_11>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 7c 01 	jmp	0x2f8	; 0x2f8 <__vector_19>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d4 e0       	ldi	r29, 0x04	; 4
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e8 eb       	ldi	r30, 0xB8	; 184
  68:	fc e0       	ldi	r31, 0x0C	; 12
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	a4 36       	cpi	r26, 0x64	; 100
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	10 e0       	ldi	r17, 0x00	; 0
  78:	a4 e6       	ldi	r26, 0x64	; 100
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a6 3b       	cpi	r26, 0xB6	; 182
  82:	b1 07       	cpc	r27, r17
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 4d 01 	call	0x29a	; 0x29a <main>
  8a:	0c 94 5a 06 	jmp	0xcb4	; 0xcb4 <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <rvHardwareInit>:
void rvADCInit(void);
void rvGPIOInit(void);
void USART_Init(void);

void rvHardwareInit(void)
{
  92:	df 93       	push	r29
  94:	cf 93       	push	r28
  96:	0f 92       	push	r0
  98:	cd b7       	in	r28, 0x3d	; 61
  9a:	de b7       	in	r29, 0x3e	; 62
	uint8_t lu8loopCount = 0;
  9c:	19 82       	std	Y+1, r1	; 0x01
	
	// GPIO Init 
	rvGPIOInit();
  9e:	0e 94 b7 00 	call	0x16e	; 0x16e <rvGPIOInit>
	
	for(lu8loopCount = 0; lu8loopCount < 16; lu8loopCount++ )
  a2:	19 82       	std	Y+1, r1	; 0x01
  a4:	11 c0       	rjmp	.+34     	; 0xc8 <rvHardwareInit+0x36>
	{
		gau8RxBuffer[lu8loopCount] = 0;
  a6:	89 81       	ldd	r24, Y+1	; 0x01
  a8:	88 2f       	mov	r24, r24
  aa:	90 e0       	ldi	r25, 0x00	; 0
  ac:	8a 55       	subi	r24, 0x5A	; 90
  ae:	9f 4f       	sbci	r25, 0xFF	; 255
  b0:	fc 01       	movw	r30, r24
  b2:	10 82       	st	Z, r1
		gau8TxBuffer[lu8loopCount] = 0;
  b4:	89 81       	ldd	r24, Y+1	; 0x01
  b6:	88 2f       	mov	r24, r24
  b8:	90 e0       	ldi	r25, 0x00	; 0
  ba:	8a 56       	subi	r24, 0x6A	; 106
  bc:	9f 4f       	sbci	r25, 0xFF	; 255
  be:	fc 01       	movw	r30, r24
  c0:	10 82       	st	Z, r1
	uint8_t lu8loopCount = 0;
	
	// GPIO Init 
	rvGPIOInit();
	
	for(lu8loopCount = 0; lu8loopCount < 16; lu8loopCount++ )
  c2:	89 81       	ldd	r24, Y+1	; 0x01
  c4:	8f 5f       	subi	r24, 0xFF	; 255
  c6:	89 83       	std	Y+1, r24	; 0x01
  c8:	89 81       	ldd	r24, Y+1	; 0x01
  ca:	80 31       	cpi	r24, 0x10	; 16
  cc:	60 f3       	brcs	.-40     	; 0xa6 <rvHardwareInit+0x14>
		gau8RxBuffer[lu8loopCount] = 0;
		gau8TxBuffer[lu8loopCount] = 0;
	}
	
	// Config timer for ISR
	rvTimer0Config();
  ce:	0e 94 70 00 	call	0xe0	; 0xe0 <rvTimer0Config>
#if 0
	//Config ADC
	rvADCInit();
#endif

	USART_Init();
  d2:	0e 94 92 00 	call	0x124	; 0x124 <USART_Init>

	//Enable Global Interrupts
	sei();
  d6:	78 94       	sei

}
  d8:	0f 90       	pop	r0
  da:	cf 91       	pop	r28
  dc:	df 91       	pop	r29
  de:	08 95       	ret

000000e0 <rvTimer0Config>:

void rvTimer0Config(void)
{
  e0:	df 93       	push	r29
  e2:	cf 93       	push	r28
  e4:	cd b7       	in	r28, 0x3d	; 61
  e6:	de b7       	in	r29, 0x3e	; 62
	// Set Prescaler = FCPU/1024
	// tick = 1Mhz/1024 = 1ms approx
	// set CTC mode for custom TOP value
	// Div by 64 prescaler 
	TCCR0 |= (1<<CS01) | (1<<CS00) | (1<<WGM01);
  e8:	83 e5       	ldi	r24, 0x53	; 83
  ea:	90 e0       	ldi	r25, 0x00	; 0
  ec:	23 e5       	ldi	r18, 0x53	; 83
  ee:	30 e0       	ldi	r19, 0x00	; 0
  f0:	f9 01       	movw	r30, r18
  f2:	20 81       	ld	r18, Z
  f4:	2b 60       	ori	r18, 0x0B	; 11
  f6:	fc 01       	movw	r30, r24
  f8:	20 83       	st	Z, r18

	//Enable Compare Match Interrupt Enable
	TIMSK |= (1<<OCIE0);
  fa:	89 e5       	ldi	r24, 0x59	; 89
  fc:	90 e0       	ldi	r25, 0x00	; 0
  fe:	29 e5       	ldi	r18, 0x59	; 89
 100:	30 e0       	ldi	r19, 0x00	; 0
 102:	f9 01       	movw	r30, r18
 104:	20 81       	ld	r18, Z
 106:	22 60       	ori	r18, 0x02	; 2
 108:	fc 01       	movw	r30, r24
 10a:	20 83       	st	Z, r18

	//Initialize Timer 0 gu16LEDTickser
	TCNT0 = 0;
 10c:	82 e5       	ldi	r24, 0x52	; 82
 10e:	90 e0       	ldi	r25, 0x00	; 0
 110:	fc 01       	movw	r30, r24
 112:	10 82       	st	Z, r1

	// Initialise Compare value (value = time(ms)/0.25ms)
	OCR0 = ISR_TICK_VALUE;	// for 10ms ISR
 114:	8c e5       	ldi	r24, 0x5C	; 92
 116:	90 e0       	ldi	r25, 0x00	; 0
 118:	2c e0       	ldi	r18, 0x0C	; 12
 11a:	fc 01       	movw	r30, r24
 11c:	20 83       	st	Z, r18
//	OCR0 = 4;	// for 1ms ISR

	
}
 11e:	cf 91       	pop	r28
 120:	df 91       	pop	r29
 122:	08 95       	ret

00000124 <USART_Init>:


void USART_Init(void)
{
 124:	df 93       	push	r29
 126:	cf 93       	push	r28
 128:	00 d0       	rcall	.+0      	; 0x12a <USART_Init+0x6>
 12a:	cd b7       	in	r28, 0x3d	; 61
 12c:	de b7       	in	r29, 0x3e	; 62
	 unsigned int ubrr = MYUBRR;
 12e:	83 e3       	ldi	r24, 0x33	; 51
 130:	90 e0       	ldi	r25, 0x00	; 0
 132:	9a 83       	std	Y+2, r25	; 0x02
 134:	89 83       	std	Y+1, r24	; 0x01
	/* Set baud rate */
	UBRRH = (unsigned char)(ubrr>>8);
 136:	80 e4       	ldi	r24, 0x40	; 64
 138:	90 e0       	ldi	r25, 0x00	; 0
 13a:	29 81       	ldd	r18, Y+1	; 0x01
 13c:	3a 81       	ldd	r19, Y+2	; 0x02
 13e:	23 2f       	mov	r18, r19
 140:	33 27       	eor	r19, r19
 142:	fc 01       	movw	r30, r24
 144:	20 83       	st	Z, r18
	UBRRL = (unsigned char)ubrr;
 146:	89 e2       	ldi	r24, 0x29	; 41
 148:	90 e0       	ldi	r25, 0x00	; 0
 14a:	29 81       	ldd	r18, Y+1	; 0x01
 14c:	fc 01       	movw	r30, r24
 14e:	20 83       	st	Z, r18
	/* Enable receiver and transmitter */
	UCSRB = (1<<RXEN)|(1<<TXEN)|(1<<RXCIE);
 150:	8a e2       	ldi	r24, 0x2A	; 42
 152:	90 e0       	ldi	r25, 0x00	; 0
 154:	28 e9       	ldi	r18, 0x98	; 152
 156:	fc 01       	movw	r30, r24
 158:	20 83       	st	Z, r18
	/* Set frame format: 8data, 1stop bit */
	UCSRC = (1<<URSEL)|(3<<UCSZ0);
 15a:	80 e4       	ldi	r24, 0x40	; 64
 15c:	90 e0       	ldi	r25, 0x00	; 0
 15e:	26 e8       	ldi	r18, 0x86	; 134
 160:	fc 01       	movw	r30, r24
 162:	20 83       	st	Z, r18
}
 164:	0f 90       	pop	r0
 166:	0f 90       	pop	r0
 168:	cf 91       	pop	r28
 16a:	df 91       	pop	r29
 16c:	08 95       	ret

0000016e <rvGPIOInit>:


void rvGPIOInit(void)
{
 16e:	df 93       	push	r29
 170:	cf 93       	push	r28
 172:	cd b7       	in	r28, 0x3d	; 61
 174:	de b7       	in	r29, 0x3e	; 62
	//Enable internal pull-ups for ports
	PORT_PU_E;
 176:	80 e5       	ldi	r24, 0x50	; 80
 178:	90 e0       	ldi	r25, 0x00	; 0
 17a:	20 e5       	ldi	r18, 0x50	; 80
 17c:	30 e0       	ldi	r19, 0x00	; 0
 17e:	f9 01       	movw	r30, r18
 180:	20 81       	ld	r18, Z
 182:	2b 7f       	andi	r18, 0xFB	; 251
 184:	fc 01       	movw	r30, r24
 186:	20 83       	st	Z, r18

	//Set o/p direction of LED port
	LAMP_PORT_DIR = 0xFF;
 188:	81 e3       	ldi	r24, 0x31	; 49
 18a:	90 e0       	ldi	r25, 0x00	; 0
 18c:	2f ef       	ldi	r18, 0xFF	; 255
 18e:	fc 01       	movw	r30, r24
 190:	20 83       	st	Z, r18

	//Set o/p direction of LED port
	MOTOR_PORT_DIR = 0xFF;
 192:	84 e3       	ldi	r24, 0x34	; 52
 194:	90 e0       	ldi	r25, 0x00	; 0
 196:	2f ef       	ldi	r18, 0xFF	; 255
 198:	fc 01       	movw	r30, r24
 19a:	20 83       	st	Z, r18

	//Set i/p direction of Switch port
	SW_PORT_DIR = 0x00;
 19c:	8a e3       	ldi	r24, 0x3A	; 58
 19e:	90 e0       	ldi	r25, 0x00	; 0
 1a0:	fc 01       	movw	r30, r24
 1a2:	10 82       	st	Z, r1
	
	// Clear motor interface signals 
	MOTOR_PORT_OUT = 0;
 1a4:	85 e3       	ldi	r24, 0x35	; 53
 1a6:	90 e0       	ldi	r25, 0x00	; 0
 1a8:	fc 01       	movw	r30, r24
 1aa:	10 82       	st	Z, r1

	// Clear LED port
	LAMP_PORT_OUT = 0;
 1ac:	82 e3       	ldi	r24, 0x32	; 50
 1ae:	90 e0       	ldi	r25, 0x00	; 0
 1b0:	fc 01       	movw	r30, r24
 1b2:	10 82       	st	Z, r1

	// Turn OFF all LEDs
	LED1_OFF;
 1b4:	82 e3       	ldi	r24, 0x32	; 50
 1b6:	90 e0       	ldi	r25, 0x00	; 0
 1b8:	22 e3       	ldi	r18, 0x32	; 50
 1ba:	30 e0       	ldi	r19, 0x00	; 0
 1bc:	f9 01       	movw	r30, r18
 1be:	20 81       	ld	r18, Z
 1c0:	20 62       	ori	r18, 0x20	; 32
 1c2:	fc 01       	movw	r30, r24
 1c4:	20 83       	st	Z, r18
	LED2_OFF;
 1c6:	82 e3       	ldi	r24, 0x32	; 50
 1c8:	90 e0       	ldi	r25, 0x00	; 0
 1ca:	22 e3       	ldi	r18, 0x32	; 50
 1cc:	30 e0       	ldi	r19, 0x00	; 0
 1ce:	f9 01       	movw	r30, r18
 1d0:	20 81       	ld	r18, Z
 1d2:	20 64       	ori	r18, 0x40	; 64
 1d4:	fc 01       	movw	r30, r24
 1d6:	20 83       	st	Z, r18
	LED3_OFF;
 1d8:	82 e3       	ldi	r24, 0x32	; 50
 1da:	90 e0       	ldi	r25, 0x00	; 0
 1dc:	22 e3       	ldi	r18, 0x32	; 50
 1de:	30 e0       	ldi	r19, 0x00	; 0
 1e0:	f9 01       	movw	r30, r18
 1e2:	20 81       	ld	r18, Z
 1e4:	20 68       	ori	r18, 0x80	; 128
 1e6:	fc 01       	movw	r30, r24
 1e8:	20 83       	st	Z, r18
	
}
 1ea:	cf 91       	pop	r28
 1ec:	df 91       	pop	r29
 1ee:	08 95       	ret

000001f0 <rvADCInit>:

void rvADCInit(void)
{
 1f0:	df 93       	push	r29
 1f2:	cf 93       	push	r28
 1f4:	0f 92       	push	r0
 1f6:	cd b7       	in	r28, 0x3d	; 61
 1f8:	de b7       	in	r29, 0x3e	; 62
	uint8_t lu8Temp = 0x00;
 1fa:	19 82       	std	Y+1, r1	; 0x01
	
	//ADC ref selection : AVcc (REFS1:0 = 01)
	ADMUX = (1<<REFS0);
 1fc:	87 e2       	ldi	r24, 0x27	; 39
 1fe:	90 e0       	ldi	r25, 0x00	; 0
 200:	20 e4       	ldi	r18, 0x40	; 64
 202:	fc 01       	movw	r30, r24
 204:	20 83       	st	Z, r18
	
	//ADC channel selection : ADC1 single ended
	ADMUX |= 0x01;
 206:	87 e2       	ldi	r24, 0x27	; 39
 208:	90 e0       	ldi	r25, 0x00	; 0
 20a:	27 e2       	ldi	r18, 0x27	; 39
 20c:	30 e0       	ldi	r19, 0x00	; 0
 20e:	f9 01       	movw	r30, r18
 210:	20 81       	ld	r18, Z
 212:	21 60       	ori	r18, 0x01	; 1
 214:	fc 01       	movw	r30, r24
 216:	20 83       	st	Z, r18
	
	//ADC result left adjust
	ADMUX |= (1<<ADLAR);
 218:	87 e2       	ldi	r24, 0x27	; 39
 21a:	90 e0       	ldi	r25, 0x00	; 0
 21c:	27 e2       	ldi	r18, 0x27	; 39
 21e:	30 e0       	ldi	r19, 0x00	; 0
 220:	f9 01       	movw	r30, r18
 222:	20 81       	ld	r18, Z
 224:	20 62       	ori	r18, 0x20	; 32
 226:	fc 01       	movw	r30, r24
 228:	20 83       	st	Z, r18
	
	//ADC trigger mode : auto trigger
	ADCSRA |= (1<< ADATE);
 22a:	86 e2       	ldi	r24, 0x26	; 38
 22c:	90 e0       	ldi	r25, 0x00	; 0
 22e:	26 e2       	ldi	r18, 0x26	; 38
 230:	30 e0       	ldi	r19, 0x00	; 0
 232:	f9 01       	movw	r30, r18
 234:	20 81       	ld	r18, Z
 236:	20 62       	ori	r18, 0x20	; 32
 238:	fc 01       	movw	r30, r24
 23a:	20 83       	st	Z, r18

	//ADC SOC auto trigger source : Timer 0 compare match
	SFIOR |= 0x60;
 23c:	80 e5       	ldi	r24, 0x50	; 80
 23e:	90 e0       	ldi	r25, 0x00	; 0
 240:	20 e5       	ldi	r18, 0x50	; 80
 242:	30 e0       	ldi	r19, 0x00	; 0
 244:	f9 01       	movw	r30, r18
 246:	20 81       	ld	r18, Z
 248:	20 66       	ori	r18, 0x60	; 96
 24a:	fc 01       	movw	r30, r24
 24c:	20 83       	st	Z, r18
	
	//ADC Enable
	ADCSRA |= (1<<ADEN);
 24e:	86 e2       	ldi	r24, 0x26	; 38
 250:	90 e0       	ldi	r25, 0x00	; 0
 252:	26 e2       	ldi	r18, 0x26	; 38
 254:	30 e0       	ldi	r19, 0x00	; 0
 256:	f9 01       	movw	r30, r18
 258:	20 81       	ld	r18, Z
 25a:	20 68       	ori	r18, 0x80	; 128
 25c:	fc 01       	movw	r30, r24
 25e:	20 83       	st	Z, r18
	
#if 1
	//Do a dummy conversion
	ADCSRA |= (1<<ADSC);
 260:	86 e2       	ldi	r24, 0x26	; 38
 262:	90 e0       	ldi	r25, 0x00	; 0
 264:	26 e2       	ldi	r18, 0x26	; 38
 266:	30 e0       	ldi	r19, 0x00	; 0
 268:	f9 01       	movw	r30, r18
 26a:	20 81       	ld	r18, Z
 26c:	20 64       	ori	r18, 0x40	; 64
 26e:	fc 01       	movw	r30, r24
 270:	20 83       	st	Z, r18

	while(0 == (ADCSRA & (1<<ADIF)));
 272:	00 00       	nop
 274:	86 e2       	ldi	r24, 0x26	; 38
 276:	90 e0       	ldi	r25, 0x00	; 0
 278:	fc 01       	movw	r30, r24
 27a:	80 81       	ld	r24, Z
 27c:	88 2f       	mov	r24, r24
 27e:	90 e0       	ldi	r25, 0x00	; 0
 280:	80 71       	andi	r24, 0x10	; 16
 282:	90 70       	andi	r25, 0x00	; 0
 284:	00 97       	sbiw	r24, 0x00	; 0
 286:	b1 f3       	breq	.-20     	; 0x274 <rvADCInit+0x84>

	lu8Temp = ADCH;
 288:	85 e2       	ldi	r24, 0x25	; 37
 28a:	90 e0       	ldi	r25, 0x00	; 0
 28c:	fc 01       	movw	r30, r24
 28e:	80 81       	ld	r24, Z
 290:	89 83       	std	Y+1, r24	; 0x01
#endif	
	

}
 292:	0f 90       	pop	r0
 294:	cf 91       	pop	r28
 296:	df 91       	pop	r29
 298:	08 95       	ret

0000029a <main>:

/************************ Function definitions ************************/


void main(void)
{
 29a:	df 93       	push	r29
 29c:	cf 93       	push	r28
 29e:	cd b7       	in	r28, 0x3d	; 61
 2a0:	de b7       	in	r29, 0x3e	; 62
	//Initialize the hardware
	rvHardwareInit();
 2a2:	0e 94 49 00 	call	0x92	; 0x92 <rvHardwareInit>
	
	H_ENABLE;
 2a6:	85 e3       	ldi	r24, 0x35	; 53
 2a8:	90 e0       	ldi	r25, 0x00	; 0
 2aa:	25 e3       	ldi	r18, 0x35	; 53
 2ac:	30 e0       	ldi	r19, 0x00	; 0
 2ae:	f9 01       	movw	r30, r18
 2b0:	20 81       	ld	r18, Z
 2b2:	24 60       	ori	r18, 0x04	; 4
 2b4:	fc 01       	movw	r30, r24
 2b6:	20 83       	st	Z, r18
	
	H_DIR_CLOCKWISE;
 2b8:	85 e3       	ldi	r24, 0x35	; 53
 2ba:	90 e0       	ldi	r25, 0x00	; 0
 2bc:	25 e3       	ldi	r18, 0x35	; 53
 2be:	30 e0       	ldi	r19, 0x00	; 0
 2c0:	f9 01       	movw	r30, r18
 2c2:	20 81       	ld	r18, Z
 2c4:	22 60       	ori	r18, 0x02	; 2
 2c6:	fc 01       	movw	r30, r24
 2c8:	20 83       	st	Z, r18

	V_ENABLE;
 2ca:	85 e3       	ldi	r24, 0x35	; 53
 2cc:	90 e0       	ldi	r25, 0x00	; 0
 2ce:	25 e3       	ldi	r18, 0x35	; 53
 2d0:	30 e0       	ldi	r19, 0x00	; 0
 2d2:	f9 01       	movw	r30, r18
 2d4:	20 81       	ld	r18, Z
 2d6:	20 64       	ori	r18, 0x40	; 64
 2d8:	fc 01       	movw	r30, r24
 2da:	20 83       	st	Z, r18
	
	V_DIR_CLOCKWISE;
 2dc:	85 e3       	ldi	r24, 0x35	; 53
 2de:	90 e0       	ldi	r25, 0x00	; 0
 2e0:	25 e3       	ldi	r18, 0x35	; 53
 2e2:	30 e0       	ldi	r19, 0x00	; 0
 2e4:	f9 01       	movw	r30, r18
 2e6:	20 81       	ld	r18, Z
 2e8:	20 62       	ori	r18, 0x20	; 32
 2ea:	fc 01       	movw	r30, r24
 2ec:	20 83       	st	Z, r18

	
	//Infinite loop
	while(1)
	{
		rvReadRequest();
 2ee:	0e 94 10 03 	call	0x620	; 0x620 <rvReadRequest>
		rvSendResponse();
 2f2:	0e 94 95 04 	call	0x92a	; 0x92a <rvSendResponse>
	}
 2f6:	fb cf       	rjmp	.-10     	; 0x2ee <main+0x54>

000002f8 <__vector_19>:


/*	This is the interrupt service routine for TIMER0 Compare Match Interrupt.
	ISR frequency : 100 usec */
ISR(TIMER0_COMP_vect)
{
 2f8:	1f 92       	push	r1
 2fa:	0f 92       	push	r0
 2fc:	0f b6       	in	r0, 0x3f	; 63
 2fe:	0f 92       	push	r0
 300:	11 24       	eor	r1, r1
 302:	2f 93       	push	r18
 304:	3f 93       	push	r19
 306:	4f 93       	push	r20
 308:	5f 93       	push	r21
 30a:	6f 93       	push	r22
 30c:	7f 93       	push	r23
 30e:	8f 93       	push	r24
 310:	9f 93       	push	r25
 312:	af 93       	push	r26
 314:	bf 93       	push	r27
 316:	ef 93       	push	r30
 318:	ff 93       	push	r31
 31a:	df 93       	push	r29
 31c:	cf 93       	push	r28
 31e:	cd b7       	in	r28, 0x3d	; 61
 320:	de b7       	in	r29, 0x3e	; 62
		
#if 0	
	rvMotorTest();
#endif
	
	if(TRUE == gu8ReqStart)
 322:	80 91 68 00 	lds	r24, 0x0068
 326:	81 30       	cpi	r24, 0x01	; 1
 328:	b9 f5       	brne	.+110    	; 0x398 <__vector_19+0xa0>
	{
		// data Rx is time in 1ms multiple. (0~255)
		// used to clock the motor and LED
		if(lu16ISRDivCounter > (gu8ReqSpeedRef * 10))
 32a:	80 91 69 00 	lds	r24, 0x0069
 32e:	88 2f       	mov	r24, r24
 330:	90 e0       	ldi	r25, 0x00	; 0
 332:	88 0f       	add	r24, r24
 334:	99 1f       	adc	r25, r25
 336:	9c 01       	movw	r18, r24
 338:	22 0f       	add	r18, r18
 33a:	33 1f       	adc	r19, r19
 33c:	22 0f       	add	r18, r18
 33e:	33 1f       	adc	r19, r19
 340:	82 0f       	add	r24, r18
 342:	93 1f       	adc	r25, r19
 344:	9c 01       	movw	r18, r24
 346:	80 91 80 00 	lds	r24, 0x0080
 34a:	90 91 81 00 	lds	r25, 0x0081
 34e:	28 17       	cp	r18, r24
 350:	39 07       	cpc	r19, r25
 352:	10 f5       	brcc	.+68     	; 0x398 <__vector_19+0xa0>
		{
			LED3_TOGGLE;
 354:	82 e3       	ldi	r24, 0x32	; 50
 356:	90 e0       	ldi	r25, 0x00	; 0
 358:	22 e3       	ldi	r18, 0x32	; 50
 35a:	30 e0       	ldi	r19, 0x00	; 0
 35c:	f9 01       	movw	r30, r18
 35e:	30 81       	ld	r19, Z
 360:	20 e8       	ldi	r18, 0x80	; 128
 362:	23 27       	eor	r18, r19
 364:	fc 01       	movw	r30, r24
 366:	20 83       	st	Z, r18
	
			H_CLK_TOGGLE;
 368:	85 e3       	ldi	r24, 0x35	; 53
 36a:	90 e0       	ldi	r25, 0x00	; 0
 36c:	25 e3       	ldi	r18, 0x35	; 53
 36e:	30 e0       	ldi	r19, 0x00	; 0
 370:	f9 01       	movw	r30, r18
 372:	30 81       	ld	r19, Z
 374:	21 e0       	ldi	r18, 0x01	; 1
 376:	23 27       	eor	r18, r19
 378:	fc 01       	movw	r30, r24
 37a:	20 83       	st	Z, r18
	
			V_CLK_TOGGLE;
 37c:	85 e3       	ldi	r24, 0x35	; 53
 37e:	90 e0       	ldi	r25, 0x00	; 0
 380:	25 e3       	ldi	r18, 0x35	; 53
 382:	30 e0       	ldi	r19, 0x00	; 0
 384:	f9 01       	movw	r30, r18
 386:	30 81       	ld	r19, Z
 388:	20 e1       	ldi	r18, 0x10	; 16
 38a:	23 27       	eor	r18, r19
 38c:	fc 01       	movw	r30, r24
 38e:	20 83       	st	Z, r18
	
	

	
			lu16ISRDivCounter = 0;
 390:	10 92 81 00 	sts	0x0081, r1
 394:	10 92 80 00 	sts	0x0080, r1
		}
	}

	rvTxSerialData();
 398:	0e 94 2a 06 	call	0xc54	; 0xc54 <rvTxSerialData>
	
	lu16ISRDivCounter++;
 39c:	80 91 80 00 	lds	r24, 0x0080
 3a0:	90 91 81 00 	lds	r25, 0x0081
 3a4:	01 96       	adiw	r24, 0x01	; 1
 3a6:	90 93 81 00 	sts	0x0081, r25
 3aa:	80 93 80 00 	sts	0x0080, r24

	// Increment global tick
	gu32TimeTicks++;
 3ae:	80 91 64 00 	lds	r24, 0x0064
 3b2:	90 91 65 00 	lds	r25, 0x0065
 3b6:	a0 91 66 00 	lds	r26, 0x0066
 3ba:	b0 91 67 00 	lds	r27, 0x0067
 3be:	01 96       	adiw	r24, 0x01	; 1
 3c0:	a1 1d       	adc	r26, r1
 3c2:	b1 1d       	adc	r27, r1
 3c4:	80 93 64 00 	sts	0x0064, r24
 3c8:	90 93 65 00 	sts	0x0065, r25
 3cc:	a0 93 66 00 	sts	0x0066, r26
 3d0:	b0 93 67 00 	sts	0x0067, r27


}
 3d4:	cf 91       	pop	r28
 3d6:	df 91       	pop	r29
 3d8:	ff 91       	pop	r31
 3da:	ef 91       	pop	r30
 3dc:	bf 91       	pop	r27
 3de:	af 91       	pop	r26
 3e0:	9f 91       	pop	r25
 3e2:	8f 91       	pop	r24
 3e4:	7f 91       	pop	r23
 3e6:	6f 91       	pop	r22
 3e8:	5f 91       	pop	r21
 3ea:	4f 91       	pop	r20
 3ec:	3f 91       	pop	r19
 3ee:	2f 91       	pop	r18
 3f0:	0f 90       	pop	r0
 3f2:	0f be       	out	0x3f, r0	; 63
 3f4:	0f 90       	pop	r0
 3f6:	1f 90       	pop	r1
 3f8:	18 95       	reti

000003fa <rvMotorTest>:



// Test stub to test both motors - Run CW - Stop - Run CCW
void rvMotorTest(void)
{
 3fa:	df 93       	push	r29
 3fc:	cf 93       	push	r28
 3fe:	cd b7       	in	r28, 0x3d	; 61
 400:	de b7       	in	r29, 0x3e	; 62
	static uint16_t lu16TestStubCounter = 0;

	if((lu16TestStubCounter > 0) && (lu16TestStubCounter <= 20000))
 402:	80 91 7e 00 	lds	r24, 0x007E
 406:	90 91 7f 00 	lds	r25, 0x007F
 40a:	00 97       	sbiw	r24, 0x00	; 0
 40c:	09 f4       	brne	.+2      	; 0x410 <rvMotorTest+0x16>
 40e:	3f c0       	rjmp	.+126    	; 0x48e <__stack+0x2f>
 410:	80 91 7e 00 	lds	r24, 0x007E
 414:	90 91 7f 00 	lds	r25, 0x007F
 418:	2e e4       	ldi	r18, 0x4E	; 78
 41a:	81 32       	cpi	r24, 0x21	; 33
 41c:	92 07       	cpc	r25, r18
 41e:	b8 f5       	brcc	.+110    	; 0x48e <__stack+0x2f>
	{
		H_ENABLE;
 420:	85 e3       	ldi	r24, 0x35	; 53
 422:	90 e0       	ldi	r25, 0x00	; 0
 424:	25 e3       	ldi	r18, 0x35	; 53
 426:	30 e0       	ldi	r19, 0x00	; 0
 428:	f9 01       	movw	r30, r18
 42a:	20 81       	ld	r18, Z
 42c:	24 60       	ori	r18, 0x04	; 4
 42e:	fc 01       	movw	r30, r24
 430:	20 83       	st	Z, r18
		H_DIR_ANTICLOCKWISE;
 432:	85 e3       	ldi	r24, 0x35	; 53
 434:	90 e0       	ldi	r25, 0x00	; 0
 436:	25 e3       	ldi	r18, 0x35	; 53
 438:	30 e0       	ldi	r19, 0x00	; 0
 43a:	f9 01       	movw	r30, r18
 43c:	20 81       	ld	r18, Z
 43e:	2d 7f       	andi	r18, 0xFD	; 253
 440:	fc 01       	movw	r30, r24
 442:	20 83       	st	Z, r18

		V_ENABLE;
 444:	85 e3       	ldi	r24, 0x35	; 53
 446:	90 e0       	ldi	r25, 0x00	; 0
 448:	25 e3       	ldi	r18, 0x35	; 53
 44a:	30 e0       	ldi	r19, 0x00	; 0
 44c:	f9 01       	movw	r30, r18
 44e:	20 81       	ld	r18, Z
 450:	20 64       	ori	r18, 0x40	; 64
 452:	fc 01       	movw	r30, r24
 454:	20 83       	st	Z, r18
		V_DIR_CLOCKWISE;
 456:	85 e3       	ldi	r24, 0x35	; 53
 458:	90 e0       	ldi	r25, 0x00	; 0
 45a:	25 e3       	ldi	r18, 0x35	; 53
 45c:	30 e0       	ldi	r19, 0x00	; 0
 45e:	f9 01       	movw	r30, r18
 460:	20 81       	ld	r18, Z
 462:	20 62       	ori	r18, 0x20	; 32
 464:	fc 01       	movw	r30, r24
 466:	20 83       	st	Z, r18
		
		LED1_ON;
 468:	82 e3       	ldi	r24, 0x32	; 50
 46a:	90 e0       	ldi	r25, 0x00	; 0
 46c:	22 e3       	ldi	r18, 0x32	; 50
 46e:	30 e0       	ldi	r19, 0x00	; 0
 470:	f9 01       	movw	r30, r18
 472:	20 81       	ld	r18, Z
 474:	2f 7d       	andi	r18, 0xDF	; 223
 476:	fc 01       	movw	r30, r24
 478:	20 83       	st	Z, r18
		LED2_OFF;
 47a:	82 e3       	ldi	r24, 0x32	; 50
 47c:	90 e0       	ldi	r25, 0x00	; 0
 47e:	22 e3       	ldi	r18, 0x32	; 50
 480:	30 e0       	ldi	r19, 0x00	; 0
 482:	f9 01       	movw	r30, r18
 484:	20 81       	ld	r18, Z
 486:	20 64       	ori	r18, 0x40	; 64
 488:	fc 01       	movw	r30, r24
 48a:	20 83       	st	Z, r18
 48c:	34 c0       	rjmp	.+104    	; 0x4f6 <__stack+0x97>
	} 
	else if((lu16TestStubCounter > 20000) && (lu16TestStubCounter <= 25000))
 48e:	80 91 7e 00 	lds	r24, 0x007E
 492:	90 91 7f 00 	lds	r25, 0x007F
 496:	fe e4       	ldi	r31, 0x4E	; 78
 498:	81 32       	cpi	r24, 0x21	; 33
 49a:	9f 07       	cpc	r25, r31
 49c:	60 f1       	brcs	.+88     	; 0x4f6 <__stack+0x97>
 49e:	80 91 7e 00 	lds	r24, 0x007E
 4a2:	90 91 7f 00 	lds	r25, 0x007F
 4a6:	21 e6       	ldi	r18, 0x61	; 97
 4a8:	89 3a       	cpi	r24, 0xA9	; 169
 4aa:	92 07       	cpc	r25, r18
 4ac:	20 f5       	brcc	.+72     	; 0x4f6 <__stack+0x97>
	{
		H_DISABLE;
 4ae:	85 e3       	ldi	r24, 0x35	; 53
 4b0:	90 e0       	ldi	r25, 0x00	; 0
 4b2:	25 e3       	ldi	r18, 0x35	; 53
 4b4:	30 e0       	ldi	r19, 0x00	; 0
 4b6:	f9 01       	movw	r30, r18
 4b8:	20 81       	ld	r18, Z
 4ba:	2b 7f       	andi	r18, 0xFB	; 251
 4bc:	fc 01       	movw	r30, r24
 4be:	20 83       	st	Z, r18
		V_DISABLE;
 4c0:	85 e3       	ldi	r24, 0x35	; 53
 4c2:	90 e0       	ldi	r25, 0x00	; 0
 4c4:	25 e3       	ldi	r18, 0x35	; 53
 4c6:	30 e0       	ldi	r19, 0x00	; 0
 4c8:	f9 01       	movw	r30, r18
 4ca:	20 81       	ld	r18, Z
 4cc:	2f 7b       	andi	r18, 0xBF	; 191
 4ce:	fc 01       	movw	r30, r24
 4d0:	20 83       	st	Z, r18

		LED1_OFF;
 4d2:	82 e3       	ldi	r24, 0x32	; 50
 4d4:	90 e0       	ldi	r25, 0x00	; 0
 4d6:	22 e3       	ldi	r18, 0x32	; 50
 4d8:	30 e0       	ldi	r19, 0x00	; 0
 4da:	f9 01       	movw	r30, r18
 4dc:	20 81       	ld	r18, Z
 4de:	20 62       	ori	r18, 0x20	; 32
 4e0:	fc 01       	movw	r30, r24
 4e2:	20 83       	st	Z, r18
		LED2_OFF;
 4e4:	82 e3       	ldi	r24, 0x32	; 50
 4e6:	90 e0       	ldi	r25, 0x00	; 0
 4e8:	22 e3       	ldi	r18, 0x32	; 50
 4ea:	30 e0       	ldi	r19, 0x00	; 0
 4ec:	f9 01       	movw	r30, r18
 4ee:	20 81       	ld	r18, Z
 4f0:	20 64       	ori	r18, 0x40	; 64
 4f2:	fc 01       	movw	r30, r24
 4f4:	20 83       	st	Z, r18
	}
	if((lu16TestStubCounter > 25000) && (lu16TestStubCounter <= 45000))
 4f6:	80 91 7e 00 	lds	r24, 0x007E
 4fa:	90 91 7f 00 	lds	r25, 0x007F
 4fe:	f1 e6       	ldi	r31, 0x61	; 97
 500:	89 3a       	cpi	r24, 0xA9	; 169
 502:	9f 07       	cpc	r25, r31
 504:	08 f4       	brcc	.+2      	; 0x508 <__stack+0xa9>
 506:	3f c0       	rjmp	.+126    	; 0x586 <__stack+0x127>
 508:	80 91 7e 00 	lds	r24, 0x007E
 50c:	90 91 7f 00 	lds	r25, 0x007F
 510:	2f ea       	ldi	r18, 0xAF	; 175
 512:	89 3c       	cpi	r24, 0xC9	; 201
 514:	92 07       	cpc	r25, r18
 516:	b8 f5       	brcc	.+110    	; 0x586 <__stack+0x127>
	{
		H_ENABLE;
 518:	85 e3       	ldi	r24, 0x35	; 53
 51a:	90 e0       	ldi	r25, 0x00	; 0
 51c:	25 e3       	ldi	r18, 0x35	; 53
 51e:	30 e0       	ldi	r19, 0x00	; 0
 520:	f9 01       	movw	r30, r18
 522:	20 81       	ld	r18, Z
 524:	24 60       	ori	r18, 0x04	; 4
 526:	fc 01       	movw	r30, r24
 528:	20 83       	st	Z, r18
		H_DIR_CLOCKWISE;
 52a:	85 e3       	ldi	r24, 0x35	; 53
 52c:	90 e0       	ldi	r25, 0x00	; 0
 52e:	25 e3       	ldi	r18, 0x35	; 53
 530:	30 e0       	ldi	r19, 0x00	; 0
 532:	f9 01       	movw	r30, r18
 534:	20 81       	ld	r18, Z
 536:	22 60       	ori	r18, 0x02	; 2
 538:	fc 01       	movw	r30, r24
 53a:	20 83       	st	Z, r18

		V_ENABLE;
 53c:	85 e3       	ldi	r24, 0x35	; 53
 53e:	90 e0       	ldi	r25, 0x00	; 0
 540:	25 e3       	ldi	r18, 0x35	; 53
 542:	30 e0       	ldi	r19, 0x00	; 0
 544:	f9 01       	movw	r30, r18
 546:	20 81       	ld	r18, Z
 548:	20 64       	ori	r18, 0x40	; 64
 54a:	fc 01       	movw	r30, r24
 54c:	20 83       	st	Z, r18
		V_DIR_ANTICLOCKWISE;
 54e:	85 e3       	ldi	r24, 0x35	; 53
 550:	90 e0       	ldi	r25, 0x00	; 0
 552:	25 e3       	ldi	r18, 0x35	; 53
 554:	30 e0       	ldi	r19, 0x00	; 0
 556:	f9 01       	movw	r30, r18
 558:	20 81       	ld	r18, Z
 55a:	2f 7d       	andi	r18, 0xDF	; 223
 55c:	fc 01       	movw	r30, r24
 55e:	20 83       	st	Z, r18
		
		LED1_OFF;
 560:	82 e3       	ldi	r24, 0x32	; 50
 562:	90 e0       	ldi	r25, 0x00	; 0
 564:	22 e3       	ldi	r18, 0x32	; 50
 566:	30 e0       	ldi	r19, 0x00	; 0
 568:	f9 01       	movw	r30, r18
 56a:	20 81       	ld	r18, Z
 56c:	20 62       	ori	r18, 0x20	; 32
 56e:	fc 01       	movw	r30, r24
 570:	20 83       	st	Z, r18
		LED2_ON;
 572:	82 e3       	ldi	r24, 0x32	; 50
 574:	90 e0       	ldi	r25, 0x00	; 0
 576:	22 e3       	ldi	r18, 0x32	; 50
 578:	30 e0       	ldi	r19, 0x00	; 0
 57a:	f9 01       	movw	r30, r18
 57c:	20 81       	ld	r18, Z
 57e:	2f 7b       	andi	r18, 0xBF	; 191
 580:	fc 01       	movw	r30, r24
 582:	20 83       	st	Z, r18
 584:	41 c0       	rjmp	.+130    	; 0x608 <__stack+0x1a9>
	} 
	else if((lu16TestStubCounter > 45000) && (lu16TestStubCounter <= 50000))
 586:	80 91 7e 00 	lds	r24, 0x007E
 58a:	90 91 7f 00 	lds	r25, 0x007F
 58e:	ff ea       	ldi	r31, 0xAF	; 175
 590:	89 3c       	cpi	r24, 0xC9	; 201
 592:	9f 07       	cpc	r25, r31
 594:	68 f1       	brcs	.+90     	; 0x5f0 <__stack+0x191>
 596:	80 91 7e 00 	lds	r24, 0x007E
 59a:	90 91 7f 00 	lds	r25, 0x007F
 59e:	23 ec       	ldi	r18, 0xC3	; 195
 5a0:	81 35       	cpi	r24, 0x51	; 81
 5a2:	92 07       	cpc	r25, r18
 5a4:	28 f5       	brcc	.+74     	; 0x5f0 <__stack+0x191>
	{
		H_DISABLE;
 5a6:	85 e3       	ldi	r24, 0x35	; 53
 5a8:	90 e0       	ldi	r25, 0x00	; 0
 5aa:	25 e3       	ldi	r18, 0x35	; 53
 5ac:	30 e0       	ldi	r19, 0x00	; 0
 5ae:	f9 01       	movw	r30, r18
 5b0:	20 81       	ld	r18, Z
 5b2:	2b 7f       	andi	r18, 0xFB	; 251
 5b4:	fc 01       	movw	r30, r24
 5b6:	20 83       	st	Z, r18
		V_DISABLE;
 5b8:	85 e3       	ldi	r24, 0x35	; 53
 5ba:	90 e0       	ldi	r25, 0x00	; 0
 5bc:	25 e3       	ldi	r18, 0x35	; 53
 5be:	30 e0       	ldi	r19, 0x00	; 0
 5c0:	f9 01       	movw	r30, r18
 5c2:	20 81       	ld	r18, Z
 5c4:	2f 7b       	andi	r18, 0xBF	; 191
 5c6:	fc 01       	movw	r30, r24
 5c8:	20 83       	st	Z, r18
		
		LED1_OFF;
 5ca:	82 e3       	ldi	r24, 0x32	; 50
 5cc:	90 e0       	ldi	r25, 0x00	; 0
 5ce:	22 e3       	ldi	r18, 0x32	; 50
 5d0:	30 e0       	ldi	r19, 0x00	; 0
 5d2:	f9 01       	movw	r30, r18
 5d4:	20 81       	ld	r18, Z
 5d6:	20 62       	ori	r18, 0x20	; 32
 5d8:	fc 01       	movw	r30, r24
 5da:	20 83       	st	Z, r18
		LED2_OFF;
 5dc:	82 e3       	ldi	r24, 0x32	; 50
 5de:	90 e0       	ldi	r25, 0x00	; 0
 5e0:	22 e3       	ldi	r18, 0x32	; 50
 5e2:	30 e0       	ldi	r19, 0x00	; 0
 5e4:	f9 01       	movw	r30, r18
 5e6:	20 81       	ld	r18, Z
 5e8:	20 64       	ori	r18, 0x40	; 64
 5ea:	fc 01       	movw	r30, r24
 5ec:	20 83       	st	Z, r18
 5ee:	0c c0       	rjmp	.+24     	; 0x608 <__stack+0x1a9>
	}
	else if (lu16TestStubCounter > 50000)
 5f0:	80 91 7e 00 	lds	r24, 0x007E
 5f4:	90 91 7f 00 	lds	r25, 0x007F
 5f8:	f3 ec       	ldi	r31, 0xC3	; 195
 5fa:	81 35       	cpi	r24, 0x51	; 81
 5fc:	9f 07       	cpc	r25, r31
 5fe:	20 f0       	brcs	.+8      	; 0x608 <__stack+0x1a9>
	{
		lu16TestStubCounter = 0;
 600:	10 92 7f 00 	sts	0x007F, r1
 604:	10 92 7e 00 	sts	0x007E, r1
	}
	
	lu16TestStubCounter++;
 608:	80 91 7e 00 	lds	r24, 0x007E
 60c:	90 91 7f 00 	lds	r25, 0x007F
 610:	01 96       	adiw	r24, 0x01	; 1
 612:	90 93 7f 00 	sts	0x007F, r25
 616:	80 93 7e 00 	sts	0x007E, r24

 61a:	cf 91       	pop	r28
 61c:	df 91       	pop	r29
 61e:	08 95       	ret

00000620 <rvReadRequest>:
void rvSendResponse(void);
uint8_t ru8PrepareTxFrame(uint8_t);
/************************ Function definitions ************************/

void rvReadRequest(void)
{
 620:	df 93       	push	r29
 622:	cf 93       	push	r28
 624:	00 d0       	rcall	.+0      	; 0x626 <rvReadRequest+0x6>
 626:	0f 92       	push	r0
 628:	cd b7       	in	r28, 0x3d	; 61
 62a:	de b7       	in	r29, 0x3e	; 62
	uint8_t lu8ReadPending = FALSE;
 62c:	19 82       	std	Y+1, r1	; 0x01
	uint8_t lu8ReadByte = 0x00;
 62e:	1a 82       	std	Y+2, r1	; 0x02
	uint8_t lu8RxChkSum = 0x00;
 630:	1b 82       	std	Y+3, r1	; 0x03
	
	
	// If latest Rx data not yet read.
	if(gu8RxWritePtr > gu8RxReadPtr)
 632:	90 91 83 00 	lds	r25, 0x0083
 636:	80 91 82 00 	lds	r24, 0x0082
 63a:	89 17       	cp	r24, r25
 63c:	80 f4       	brcc	.+32     	; 0x65e <rvReadRequest+0x3e>
	{
		lu8ReadByte = gau8RxBuffer[gu8RxReadPtr];
 63e:	80 91 82 00 	lds	r24, 0x0082
 642:	88 2f       	mov	r24, r24
 644:	90 e0       	ldi	r25, 0x00	; 0
 646:	8a 55       	subi	r24, 0x5A	; 90
 648:	9f 4f       	sbci	r25, 0xFF	; 255
 64a:	fc 01       	movw	r30, r24
 64c:	80 81       	ld	r24, Z
 64e:	8a 83       	std	Y+2, r24	; 0x02
		gu8RxReadPtr++;
 650:	80 91 82 00 	lds	r24, 0x0082
 654:	8f 5f       	subi	r24, 0xFF	; 255
 656:	80 93 82 00 	sts	0x0082, r24
		
		lu8ReadPending = TRUE;
 65a:	81 e0       	ldi	r24, 0x01	; 1
 65c:	89 83       	std	Y+1, r24	; 0x01
	}
	
	// if read is pending
	if(TRUE == lu8ReadPending)
 65e:	89 81       	ldd	r24, Y+1	; 0x01
 660:	81 30       	cpi	r24, 0x01	; 1
 662:	09 f0       	breq	.+2      	; 0x666 <rvReadRequest+0x46>
 664:	85 c0       	rjmp	.+266    	; 0x770 <rvReadRequest+0x150>
	{
		// If valid SOF detected 
		if((RX_SOF_WAIT == fseRxFrameReadState) && (COMM_SOF == lu8ReadByte))
 666:	80 91 8e 00 	lds	r24, 0x008E
 66a:	88 23       	and	r24, r24
 66c:	51 f4       	brne	.+20     	; 0x682 <rvReadRequest+0x62>
 66e:	8a 81       	ldd	r24, Y+2	; 0x02
 670:	85 35       	cpi	r24, 0x55	; 85
 672:	39 f4       	brne	.+14     	; 0x682 <rvReadRequest+0x62>
		{
			fseRxFrameReadState = RX_SOF_READ;
 674:	81 e0       	ldi	r24, 0x01	; 1
 676:	80 93 8e 00 	sts	0x008E, r24
			
			fsu8RxChkSumCalc = lu8ReadByte;
 67a:	8a 81       	ldd	r24, Y+2	; 0x02
 67c:	80 93 8d 00 	sts	0x008D, r24
 680:	77 c0       	rjmp	.+238    	; 0x770 <rvReadRequest+0x150>
		}
		// If valid Rx Frame No detected 		
		else if((RX_SOF_READ == fseRxFrameReadState) && ((lu8ReadByte > 0x10) && (lu8ReadByte < 0x19)) && (0x00 == fsu8RxFrameID))
 682:	80 91 8e 00 	lds	r24, 0x008E
 686:	81 30       	cpi	r24, 0x01	; 1
 688:	b9 f4       	brne	.+46     	; 0x6b8 <rvReadRequest+0x98>
 68a:	8a 81       	ldd	r24, Y+2	; 0x02
 68c:	81 31       	cpi	r24, 0x11	; 17
 68e:	a0 f0       	brcs	.+40     	; 0x6b8 <rvReadRequest+0x98>
 690:	8a 81       	ldd	r24, Y+2	; 0x02
 692:	89 31       	cpi	r24, 0x19	; 25
 694:	88 f4       	brcc	.+34     	; 0x6b8 <rvReadRequest+0x98>
 696:	80 91 87 00 	lds	r24, 0x0087
 69a:	88 23       	and	r24, r24
 69c:	69 f4       	brne	.+26     	; 0x6b8 <rvReadRequest+0x98>
		{
			fsu8RxFrameID = lu8ReadByte;
 69e:	8a 81       	ldd	r24, Y+2	; 0x02
 6a0:	80 93 87 00 	sts	0x0087, r24
			fsu8RxChkSumCalc += lu8ReadByte;
 6a4:	90 91 8d 00 	lds	r25, 0x008D
 6a8:	8a 81       	ldd	r24, Y+2	; 0x02
 6aa:	89 0f       	add	r24, r25
 6ac:	80 93 8d 00 	sts	0x008D, r24
			
			fseRxFrameReadState = RX_FRAME_NO_READ;
 6b0:	82 e0       	ldi	r24, 0x02	; 2
 6b2:	80 93 8e 00 	sts	0x008E, r24
 6b6:	5c c0       	rjmp	.+184    	; 0x770 <rvReadRequest+0x150>
		}
		// If valid DLC detected 
		else if((RX_FRAME_NO_READ == fseRxFrameReadState) && ((lu8ReadByte > 0) && (lu8ReadByte <= 4)))
 6b8:	80 91 8e 00 	lds	r24, 0x008E
 6bc:	82 30       	cpi	r24, 0x02	; 2
 6be:	99 f4       	brne	.+38     	; 0x6e6 <rvReadRequest+0xc6>
 6c0:	8a 81       	ldd	r24, Y+2	; 0x02
 6c2:	88 23       	and	r24, r24
 6c4:	81 f0       	breq	.+32     	; 0x6e6 <rvReadRequest+0xc6>
 6c6:	8a 81       	ldd	r24, Y+2	; 0x02
 6c8:	85 30       	cpi	r24, 0x05	; 5
 6ca:	68 f4       	brcc	.+26     	; 0x6e6 <rvReadRequest+0xc6>
		{
			fsu8RxDLC = lu8ReadByte;
 6cc:	8a 81       	ldd	r24, Y+2	; 0x02
 6ce:	80 93 88 00 	sts	0x0088, r24
			fsu8RxChkSumCalc += lu8ReadByte;
 6d2:	90 91 8d 00 	lds	r25, 0x008D
 6d6:	8a 81       	ldd	r24, Y+2	; 0x02
 6d8:	89 0f       	add	r24, r25
 6da:	80 93 8d 00 	sts	0x008D, r24
			
			fseRxFrameReadState = RX_DLC_READ;
 6de:	83 e0       	ldi	r24, 0x03	; 3
 6e0:	80 93 8e 00 	sts	0x008E, r24
 6e4:	45 c0       	rjmp	.+138    	; 0x770 <rvReadRequest+0x150>
		}
		// Read Rx data bytes
		else if(RX_DLC_READ == fseRxFrameReadState)
 6e6:	80 91 8e 00 	lds	r24, 0x008E
 6ea:	83 30       	cpi	r24, 0x03	; 3
 6ec:	09 f5       	brne	.+66     	; 0x730 <rvReadRequest+0x110>
		{
			if(fsu8RxDLC > 0)
 6ee:	80 91 88 00 	lds	r24, 0x0088
 6f2:	88 23       	and	r24, r24
 6f4:	e9 f1       	breq	.+122    	; 0x770 <rvReadRequest+0x150>
			{
				fsau8RxDataBuff[fsu8RxDLC - 1] = lu8ReadByte;
 6f6:	80 91 88 00 	lds	r24, 0x0088
 6fa:	88 2f       	mov	r24, r24
 6fc:	90 e0       	ldi	r25, 0x00	; 0
 6fe:	01 97       	sbiw	r24, 0x01	; 1
 700:	87 57       	subi	r24, 0x77	; 119
 702:	9f 4f       	sbci	r25, 0xFF	; 255
 704:	2a 81       	ldd	r18, Y+2	; 0x02
 706:	fc 01       	movw	r30, r24
 708:	20 83       	st	Z, r18
				fsu8RxChkSumCalc += lu8ReadByte;
 70a:	90 91 8d 00 	lds	r25, 0x008D
 70e:	8a 81       	ldd	r24, Y+2	; 0x02
 710:	89 0f       	add	r24, r25
 712:	80 93 8d 00 	sts	0x008D, r24
				
				fsu8RxDLC--;
 716:	80 91 88 00 	lds	r24, 0x0088
 71a:	81 50       	subi	r24, 0x01	; 1
 71c:	80 93 88 00 	sts	0x0088, r24
				
				// If Rx data bytes completely read
				if(0 == fsu8RxDLC)
 720:	80 91 88 00 	lds	r24, 0x0088
 724:	88 23       	and	r24, r24
 726:	21 f5       	brne	.+72     	; 0x770 <rvReadRequest+0x150>
				{
					fseRxFrameReadState = RX_DATA_READ;
 728:	84 e0       	ldi	r24, 0x04	; 4
 72a:	80 93 8e 00 	sts	0x008E, r24
 72e:	20 c0       	rjmp	.+64     	; 0x770 <rvReadRequest+0x150>
				}
			}
		}
		// Read checksum
		else if(RX_DATA_READ == fseRxFrameReadState)
 730:	80 91 8e 00 	lds	r24, 0x008E
 734:	84 30       	cpi	r24, 0x04	; 4
 736:	59 f4       	brne	.+22     	; 0x74e <rvReadRequest+0x12e>
		{
			lu8RxChkSum = lu8ReadByte;
 738:	8a 81       	ldd	r24, Y+2	; 0x02
 73a:	8b 83       	std	Y+3, r24	; 0x03
			
			// verify checksum
			if(fsu8RxChkSumCalc == lu8RxChkSum)
 73c:	90 91 8d 00 	lds	r25, 0x008D
 740:	8b 81       	ldd	r24, Y+3	; 0x03
 742:	98 17       	cp	r25, r24
 744:	a9 f4       	brne	.+42     	; 0x770 <rvReadRequest+0x150>
			{
				fseRxFrameReadState = RX_CHKSUM_READ;
 746:	85 e0       	ldi	r24, 0x05	; 5
 748:	80 93 8e 00 	sts	0x008E, r24
 74c:	11 c0       	rjmp	.+34     	; 0x770 <rvReadRequest+0x150>
			}
		}
		// if valid EOF is detected		
		else if((RX_CHKSUM_READ == fseRxFrameReadState) && (COMM_EOF == lu8ReadByte))
 74e:	80 91 8e 00 	lds	r24, 0x008E
 752:	85 30       	cpi	r24, 0x05	; 5
 754:	59 f4       	brne	.+22     	; 0x76c <rvReadRequest+0x14c>
 756:	8a 81       	ldd	r24, Y+2	; 0x02
 758:	8a 3a       	cpi	r24, 0xAA	; 170
 75a:	41 f4       	brne	.+16     	; 0x76c <rvReadRequest+0x14c>
		{
			gu8RxReadPtr = 0;
 75c:	10 92 82 00 	sts	0x0082, r1
			gu8RxWritePtr = 0;
 760:	10 92 83 00 	sts	0x0083, r1

			fseRxFrameReadState = RX_EOF_READ;
 764:	86 e0       	ldi	r24, 0x06	; 6
 766:	80 93 8e 00 	sts	0x008E, r24
 76a:	02 c0       	rjmp	.+4      	; 0x770 <rvReadRequest+0x150>
		}
		// invalid data
		else
		{
			// reset frame reading
			rvClearRxData();
 76c:	0e 94 82 04 	call	0x904	; 0x904 <rvClearRxData>
		
	}
	
	
	// process data from the valid frame
	if(RX_EOF_READ == fseRxFrameReadState)
 770:	80 91 8e 00 	lds	r24, 0x008E
 774:	86 30       	cpi	r24, 0x06	; 6
 776:	21 f4       	brne	.+8      	; 0x780 <rvReadRequest+0x160>
	{
		rvProcessRequest();				// Extract Information from Request frames
 778:	0e 94 c6 03 	call	0x78c	; 0x78c <rvProcessRequest>
		rvClearRxData();				// Clear Rx data for next reception
 77c:	0e 94 82 04 	call	0x904	; 0x904 <rvClearRxData>
	}
	
}
 780:	0f 90       	pop	r0
 782:	0f 90       	pop	r0
 784:	0f 90       	pop	r0
 786:	cf 91       	pop	r28
 788:	df 91       	pop	r29
 78a:	08 95       	ret

0000078c <rvProcessRequest>:


void rvProcessRequest(void)
{
 78c:	df 93       	push	r29
 78e:	cf 93       	push	r28
 790:	cd b7       	in	r28, 0x3d	; 61
 792:	de b7       	in	r29, 0x3e	; 62
	// process as per Frame ID 
	switch(fsu8RxFrameID)
 794:	80 91 87 00 	lds	r24, 0x0087
 798:	88 2f       	mov	r24, r24
 79a:	90 e0       	ldi	r25, 0x00	; 0
 79c:	84 31       	cpi	r24, 0x14	; 20
 79e:	91 05       	cpc	r25, r1
 7a0:	09 f4       	brne	.+2      	; 0x7a4 <rvProcessRequest+0x18>
 7a2:	52 c0       	rjmp	.+164    	; 0x848 <rvProcessRequest+0xbc>
 7a4:	85 31       	cpi	r24, 0x15	; 21
 7a6:	91 05       	cpc	r25, r1
 7a8:	5c f4       	brge	.+22     	; 0x7c0 <rvProcessRequest+0x34>
 7aa:	82 31       	cpi	r24, 0x12	; 18
 7ac:	91 05       	cpc	r25, r1
 7ae:	81 f1       	breq	.+96     	; 0x810 <rvProcessRequest+0x84>
 7b0:	83 31       	cpi	r24, 0x13	; 19
 7b2:	91 05       	cpc	r25, r1
 7b4:	0c f0       	brlt	.+2      	; 0x7b8 <rvProcessRequest+0x2c>
 7b6:	43 c0       	rjmp	.+134    	; 0x83e <rvProcessRequest+0xb2>
 7b8:	81 31       	cpi	r24, 0x11	; 17
 7ba:	91 05       	cpc	r25, r1
 7bc:	91 f0       	breq	.+36     	; 0x7e2 <rvProcessRequest+0x56>
						gu16ReqDegreesSetH = fsau8RxDataBuff[0] | ((uint16_t)fsau8RxDataBuff[1] << 8);
						gu16ReqDegreesSetV = fsau8RxDataBuff[2] | ((uint16_t)fsau8RxDataBuff[3] << 8);

						break;

		default		:	break;
 7be:	9f c0       	rjmp	.+318    	; 0x8fe <rvProcessRequest+0x172>


void rvProcessRequest(void)
{
	// process as per Frame ID 
	switch(fsu8RxFrameID)
 7c0:	86 31       	cpi	r24, 0x16	; 22
 7c2:	91 05       	cpc	r25, r1
 7c4:	09 f4       	brne	.+2      	; 0x7c8 <rvProcessRequest+0x3c>
 7c6:	6d c0       	rjmp	.+218    	; 0x8a2 <rvProcessRequest+0x116>
 7c8:	86 31       	cpi	r24, 0x16	; 22
 7ca:	91 05       	cpc	r25, r1
 7cc:	0c f4       	brge	.+2      	; 0x7d0 <rvProcessRequest+0x44>
 7ce:	48 c0       	rjmp	.+144    	; 0x860 <rvProcessRequest+0xd4>
 7d0:	87 31       	cpi	r24, 0x17	; 23
 7d2:	91 05       	cpc	r25, r1
 7d4:	09 f4       	brne	.+2      	; 0x7d8 <rvProcessRequest+0x4c>
 7d6:	6a c0       	rjmp	.+212    	; 0x8ac <rvProcessRequest+0x120>
 7d8:	88 31       	cpi	r24, 0x18	; 24
 7da:	91 05       	cpc	r25, r1
 7dc:	09 f4       	brne	.+2      	; 0x7e0 <rvProcessRequest+0x54>
 7de:	6e c0       	rjmp	.+220    	; 0x8bc <rvProcessRequest+0x130>
						gu16ReqDegreesSetH = fsau8RxDataBuff[0] | ((uint16_t)fsau8RxDataBuff[1] << 8);
						gu16ReqDegreesSetV = fsau8RxDataBuff[2] | ((uint16_t)fsau8RxDataBuff[3] << 8);

						break;

		default		:	break;
 7e0:	8e c0       	rjmp	.+284    	; 0x8fe <rvProcessRequest+0x172>
{
	// process as per Frame ID 
	switch(fsu8RxFrameID)
	{
		case REQ_START_STOP	:	// Request - Start Stop 
						gu8ReqStart = fsau8RxDataBuff[0];
 7e2:	80 91 89 00 	lds	r24, 0x0089
 7e6:	80 93 68 00 	sts	0x0068, r24
							
						LED1_ON;
 7ea:	82 e3       	ldi	r24, 0x32	; 50
 7ec:	90 e0       	ldi	r25, 0x00	; 0
 7ee:	22 e3       	ldi	r18, 0x32	; 50
 7f0:	30 e0       	ldi	r19, 0x00	; 0
 7f2:	f9 01       	movw	r30, r18
 7f4:	20 81       	ld	r18, Z
 7f6:	2f 7d       	andi	r18, 0xDF	; 223
 7f8:	fc 01       	movw	r30, r24
 7fa:	20 83       	st	Z, r18
						LED2_OFF;
 7fc:	82 e3       	ldi	r24, 0x32	; 50
 7fe:	90 e0       	ldi	r25, 0x00	; 0
 800:	22 e3       	ldi	r18, 0x32	; 50
 802:	30 e0       	ldi	r19, 0x00	; 0
 804:	f9 01       	movw	r30, r18
 806:	20 81       	ld	r18, Z
 808:	20 64       	ori	r18, 0x40	; 64
 80a:	fc 01       	movw	r30, r24
 80c:	20 83       	st	Z, r18

						break;
 80e:	77 c0       	rjmp	.+238    	; 0x8fe <rvProcessRequest+0x172>
			
		case REQ_SPEED	:		// Request - Speed
						gu8ReqSpeedRef = fsau8RxDataBuff[0];
 810:	80 91 89 00 	lds	r24, 0x0089
 814:	80 93 69 00 	sts	0x0069, r24
							
						LED1_OFF;
 818:	82 e3       	ldi	r24, 0x32	; 50
 81a:	90 e0       	ldi	r25, 0x00	; 0
 81c:	22 e3       	ldi	r18, 0x32	; 50
 81e:	30 e0       	ldi	r19, 0x00	; 0
 820:	f9 01       	movw	r30, r18
 822:	20 81       	ld	r18, Z
 824:	20 62       	ori	r18, 0x20	; 32
 826:	fc 01       	movw	r30, r24
 828:	20 83       	st	Z, r18
						LED2_ON;
 82a:	82 e3       	ldi	r24, 0x32	; 50
 82c:	90 e0       	ldi	r25, 0x00	; 0
 82e:	22 e3       	ldi	r18, 0x32	; 50
 830:	30 e0       	ldi	r19, 0x00	; 0
 832:	f9 01       	movw	r30, r18
 834:	20 81       	ld	r18, Z
 836:	2f 7b       	andi	r18, 0xBF	; 191
 838:	fc 01       	movw	r30, r24
 83a:	20 83       	st	Z, r18

						break;
 83c:	60 c0       	rjmp	.+192    	; 0x8fe <rvProcessRequest+0x172>
							
		case REQ_MODE	:		// Request - Mode
						gu8ReqMode = fsau8RxDataBuff[0];
 83e:	80 91 89 00 	lds	r24, 0x0089
 842:	80 93 6a 00 	sts	0x006A, r24

						break;
 846:	5b c0       	rjmp	.+182    	; 0x8fe <rvProcessRequest+0x172>
							
		case REQ_DIRECTION	:	// Request - Direction
						gu8ReqDirectionH = fsau8RxDataBuff[0] & 0x0F;
 848:	80 91 89 00 	lds	r24, 0x0089
 84c:	8f 70       	andi	r24, 0x0F	; 15
 84e:	80 93 6b 00 	sts	0x006B, r24
						gu8ReqDirectionV = (fsau8RxDataBuff[0] & 0xF0) >> 4;
 852:	80 91 89 00 	lds	r24, 0x0089
 856:	82 95       	swap	r24
 858:	8f 70       	andi	r24, 0x0F	; 15
 85a:	80 93 6c 00 	sts	0x006C, r24

						break;
 85e:	4f c0       	rjmp	.+158    	; 0x8fe <rvProcessRequest+0x172>

		case REQ_PULSE_COUNT :	// Request - Pulse Count
						gu16ReqPulseTargetH = fsau8RxDataBuff[0] | ((uint16_t)fsau8RxDataBuff[1] << 8);
 860:	80 91 89 00 	lds	r24, 0x0089
 864:	28 2f       	mov	r18, r24
 866:	30 e0       	ldi	r19, 0x00	; 0
 868:	80 91 8a 00 	lds	r24, 0x008A
 86c:	88 2f       	mov	r24, r24
 86e:	90 e0       	ldi	r25, 0x00	; 0
 870:	98 2f       	mov	r25, r24
 872:	88 27       	eor	r24, r24
 874:	82 2b       	or	r24, r18
 876:	93 2b       	or	r25, r19
 878:	90 93 6e 00 	sts	0x006E, r25
 87c:	80 93 6d 00 	sts	0x006D, r24
						gu16ReqPulseTargetV = fsau8RxDataBuff[2] | ((uint16_t)fsau8RxDataBuff[3] << 8);
 880:	80 91 8b 00 	lds	r24, 0x008B
 884:	28 2f       	mov	r18, r24
 886:	30 e0       	ldi	r19, 0x00	; 0
 888:	80 91 8c 00 	lds	r24, 0x008C
 88c:	88 2f       	mov	r24, r24
 88e:	90 e0       	ldi	r25, 0x00	; 0
 890:	98 2f       	mov	r25, r24
 892:	88 27       	eor	r24, r24
 894:	82 2b       	or	r24, r18
 896:	93 2b       	or	r25, r19
 898:	90 93 70 00 	sts	0x0070, r25
 89c:	80 93 6f 00 	sts	0x006F, r24

						break;
 8a0:	2e c0       	rjmp	.+92     	; 0x8fe <rvProcessRequest+0x172>

		case REQ_ZERO	:		// Request - Zero Set
						gu8ReqZeroSet = fsau8RxDataBuff[0];
 8a2:	80 91 89 00 	lds	r24, 0x0089
 8a6:	80 93 71 00 	sts	0x0071, r24

						break;
 8aa:	29 c0       	rjmp	.+82     	; 0x8fe <rvProcessRequest+0x172>
							
		case REQ_QUADRANT :		// Request - Quadrant Set
						gu8ReqQuadrantSet = fsau8RxDataBuff[0];
 8ac:	80 91 89 00 	lds	r24, 0x0089
 8b0:	80 93 60 00 	sts	0x0060, r24

						gu8SendQuadrantResp = TRUE;				// Set response request for quadrant feedback
 8b4:	81 e0       	ldi	r24, 0x01	; 1
 8b6:	80 93 86 00 	sts	0x0086, r24
						
						break;
 8ba:	21 c0       	rjmp	.+66     	; 0x8fe <rvProcessRequest+0x172>

		case REQ_DEGREES :	// Request - Degrees Count
						gu16ReqDegreesSetH = fsau8RxDataBuff[0] | ((uint16_t)fsau8RxDataBuff[1] << 8);
 8bc:	80 91 89 00 	lds	r24, 0x0089
 8c0:	28 2f       	mov	r18, r24
 8c2:	30 e0       	ldi	r19, 0x00	; 0
 8c4:	80 91 8a 00 	lds	r24, 0x008A
 8c8:	88 2f       	mov	r24, r24
 8ca:	90 e0       	ldi	r25, 0x00	; 0
 8cc:	98 2f       	mov	r25, r24
 8ce:	88 27       	eor	r24, r24
 8d0:	82 2b       	or	r24, r18
 8d2:	93 2b       	or	r25, r19
 8d4:	90 93 73 00 	sts	0x0073, r25
 8d8:	80 93 72 00 	sts	0x0072, r24
						gu16ReqDegreesSetV = fsau8RxDataBuff[2] | ((uint16_t)fsau8RxDataBuff[3] << 8);
 8dc:	80 91 8b 00 	lds	r24, 0x008B
 8e0:	28 2f       	mov	r18, r24
 8e2:	30 e0       	ldi	r19, 0x00	; 0
 8e4:	80 91 8c 00 	lds	r24, 0x008C
 8e8:	88 2f       	mov	r24, r24
 8ea:	90 e0       	ldi	r25, 0x00	; 0
 8ec:	98 2f       	mov	r25, r24
 8ee:	88 27       	eor	r24, r24
 8f0:	82 2b       	or	r24, r18
 8f2:	93 2b       	or	r25, r19
 8f4:	90 93 75 00 	sts	0x0075, r25
 8f8:	80 93 74 00 	sts	0x0074, r24

						break;
 8fc:	00 00       	nop

		default		:	break;
	}

}
 8fe:	cf 91       	pop	r28
 900:	df 91       	pop	r29
 902:	08 95       	ret

00000904 <rvClearRxData>:

void rvClearRxData(void)
{
 904:	df 93       	push	r29
 906:	cf 93       	push	r28
 908:	cd b7       	in	r28, 0x3d	; 61
 90a:	de b7       	in	r29, 0x3e	; 62
	
	gu8RxReadPtr = 0;
 90c:	10 92 82 00 	sts	0x0082, r1
	gu8RxWritePtr = 0;
 910:	10 92 83 00 	sts	0x0083, r1

	fseRxFrameReadState = RX_SOF_WAIT;
 914:	10 92 8e 00 	sts	0x008E, r1

	fsu8RxChkSumCalc = 0x00;
 918:	10 92 8d 00 	sts	0x008D, r1
	fsu8RxDLC = 0x00;
 91c:	10 92 88 00 	sts	0x0088, r1
	fsu8RxFrameID = 0x00;
 920:	10 92 87 00 	sts	0x0087, r1
}
 924:	cf 91       	pop	r28
 926:	df 91       	pop	r29
 928:	08 95       	ret

0000092a <rvSendResponse>:

void rvSendResponse(void)
{
 92a:	ef 92       	push	r14
 92c:	ff 92       	push	r15
 92e:	0f 93       	push	r16
 930:	1f 93       	push	r17
 932:	df 93       	push	r29
 934:	cf 93       	push	r28
 936:	cd b7       	in	r28, 0x3d	; 61
 938:	de b7       	in	r29, 0x3e	; 62
	
	
	
	
	// Every Tx cycle - 200 msec 
	if(gu32TimeTicks - lsu32SendTimer >= T_200MS)
 93a:	20 91 64 00 	lds	r18, 0x0064
 93e:	30 91 65 00 	lds	r19, 0x0065
 942:	40 91 66 00 	lds	r20, 0x0066
 946:	50 91 67 00 	lds	r21, 0x0067
 94a:	80 91 92 00 	lds	r24, 0x0092
 94e:	90 91 93 00 	lds	r25, 0x0093
 952:	a0 91 94 00 	lds	r26, 0x0094
 956:	b0 91 95 00 	lds	r27, 0x0095
 95a:	79 01       	movw	r14, r18
 95c:	8a 01       	movw	r16, r20
 95e:	e8 1a       	sub	r14, r24
 960:	f9 0a       	sbc	r15, r25
 962:	0a 0b       	sbc	r16, r26
 964:	1b 0b       	sbc	r17, r27
 966:	d8 01       	movw	r26, r16
 968:	c7 01       	movw	r24, r14
 96a:	80 3d       	cpi	r24, 0xD0	; 208
 96c:	07 e0       	ldi	r16, 0x07	; 7
 96e:	90 07       	cpc	r25, r16
 970:	00 e0       	ldi	r16, 0x00	; 0
 972:	a0 07       	cpc	r26, r16
 974:	00 e0       	ldi	r16, 0x00	; 0
 976:	b0 07       	cpc	r27, r16
 978:	08 f4       	brcc	.+2      	; 0x97c <rvSendResponse+0x52>
 97a:	4f c0       	rjmp	.+158    	; 0xa1a <rvSendResponse+0xf0>
	{
		// load timer for next count
		lsu32SendTimer = gu32TimeTicks;
 97c:	80 91 64 00 	lds	r24, 0x0064
 980:	90 91 65 00 	lds	r25, 0x0065
 984:	a0 91 66 00 	lds	r26, 0x0066
 988:	b0 91 67 00 	lds	r27, 0x0067
 98c:	80 93 92 00 	sts	0x0092, r24
 990:	90 93 93 00 	sts	0x0093, r25
 994:	a0 93 94 00 	sts	0x0094, r26
 998:	b0 93 95 00 	sts	0x0095, r27
		
		// If previous Tx was complete
		if(TRUE == gu8SerialTxDone)
 99c:	80 91 62 00 	lds	r24, 0x0062
 9a0:	81 30       	cpi	r24, 0x01	; 1
 9a2:	d9 f5       	brne	.+118    	; 0xa1a <rvSendResponse+0xf0>
		{
			// If Quadrant response was requested
			if(TRUE == gu8SendQuadrantResp)
 9a4:	80 91 86 00 	lds	r24, 0x0086
 9a8:	81 30       	cpi	r24, 0x01	; 1
 9aa:	31 f4       	brne	.+12     	; 0x9b8 <rvSendResponse+0x8e>
			{
				// clear request
				gu8SendQuadrantResp = FALSE;
 9ac:	10 92 86 00 	sts	0x0086, r1

				lsu8NextTxFrame = RESP_QUADRANT;					// Select Quadrant frame
 9b0:	87 e2       	ldi	r24, 0x27	; 39
 9b2:	80 93 63 00 	sts	0x0063, r24
 9b6:	27 c0       	rjmp	.+78     	; 0xa06 <rvSendResponse+0xdc>
			}
			else if(RESP_SYS_STATUS == lsu8NextTxFrame)
 9b8:	80 91 63 00 	lds	r24, 0x0063
 9bc:	81 32       	cpi	r24, 0x21	; 33
 9be:	81 f4       	brne	.+32     	; 0x9e0 <rvSendResponse+0xb6>
			{
				if(MODE_NORMAL == gu8ReqMode)
 9c0:	80 91 6a 00 	lds	r24, 0x006A
 9c4:	88 23       	and	r24, r24
 9c6:	21 f4       	brne	.+8      	; 0x9d0 <rvSendResponse+0xa6>
				{
					lsu8NextTxFrame = RESP_PULSE_COUNT;				// Select Pulse elapsed frame
 9c8:	85 e2       	ldi	r24, 0x25	; 37
 9ca:	80 93 63 00 	sts	0x0063, r24
 9ce:	1b c0       	rjmp	.+54     	; 0xa06 <rvSendResponse+0xdc>
				}
				else if(MODE_SCAN == gu8ReqMode)					
 9d0:	80 91 6a 00 	lds	r24, 0x006A
 9d4:	81 30       	cpi	r24, 0x01	; 1
 9d6:	b9 f4       	brne	.+46     	; 0xa06 <rvSendResponse+0xdc>
				{
					lsu8NextTxFrame = RESP_DEGREES;					// Select degrees elapsed frame
 9d8:	88 e2       	ldi	r24, 0x28	; 40
 9da:	80 93 63 00 	sts	0x0063, r24
 9de:	13 c0       	rjmp	.+38     	; 0xa06 <rvSendResponse+0xdc>
				}					
			}
			else if((RESP_DEGREES == lsu8NextTxFrame) ||
 9e0:	80 91 63 00 	lds	r24, 0x0063
 9e4:	88 32       	cpi	r24, 0x28	; 40
 9e6:	21 f0       	breq	.+8      	; 0x9f0 <rvSendResponse+0xc6>
					(RESP_PULSE_COUNT == lsu8NextTxFrame))
 9e8:	80 91 63 00 	lds	r24, 0x0063
				else if(MODE_SCAN == gu8ReqMode)					
				{
					lsu8NextTxFrame = RESP_DEGREES;					// Select degrees elapsed frame
				}					
			}
			else if((RESP_DEGREES == lsu8NextTxFrame) ||
 9ec:	85 32       	cpi	r24, 0x25	; 37
 9ee:	21 f4       	brne	.+8      	; 0x9f8 <rvSendResponse+0xce>
					(RESP_PULSE_COUNT == lsu8NextTxFrame))
			{
				lsu8NextTxFrame = RESP_SYS_STATUS;					// Select System status frame
 9f0:	81 e2       	ldi	r24, 0x21	; 33
 9f2:	80 93 63 00 	sts	0x0063, r24
 9f6:	07 c0       	rjmp	.+14     	; 0xa06 <rvSendResponse+0xdc>
			}
			else if(RESP_QUADRANT == lsu8NextTxFrame)
 9f8:	80 91 63 00 	lds	r24, 0x0063
 9fc:	87 32       	cpi	r24, 0x27	; 39
 9fe:	19 f4       	brne	.+6      	; 0xa06 <rvSendResponse+0xdc>
			{
				lsu8NextTxFrame = RESP_SYS_STATUS;					// Select System status frame
 a00:	81 e2       	ldi	r24, 0x21	; 33
 a02:	80 93 63 00 	sts	0x0063, r24
			}
	
			// Indicate serial Tx request is pending
			gu8SerialTxDone = FALSE;					
 a06:	10 92 62 00 	sts	0x0062, r1
			
			gu8TxPtr = 0;
 a0a:	10 92 84 00 	sts	0x0084, r1
			
			// Prepare frame data as per selected frame ID.
			// Load number of bytes to be Tx.
			// Updating target pointer of Tx buffer initiates transmission
			gu8TxPtrTarget = ru8PrepareTxFrame(lsu8NextTxFrame);
 a0e:	80 91 63 00 	lds	r24, 0x0063
 a12:	0e 94 14 05 	call	0xa28	; 0xa28 <ru8PrepareTxFrame>
 a16:	80 93 85 00 	sts	0x0085, r24
			
			
		}
	}
	
}
 a1a:	cf 91       	pop	r28
 a1c:	df 91       	pop	r29
 a1e:	1f 91       	pop	r17
 a20:	0f 91       	pop	r16
 a22:	ff 90       	pop	r15
 a24:	ef 90       	pop	r14
 a26:	08 95       	ret

00000a28 <ru8PrepareTxFrame>:


uint8_t ru8PrepareTxFrame(uint8_t lu8TxFrameID)
{
 a28:	df 93       	push	r29
 a2a:	cf 93       	push	r28
 a2c:	00 d0       	rcall	.+0      	; 0xa2e <ru8PrepareTxFrame+0x6>
 a2e:	00 d0       	rcall	.+0      	; 0xa30 <ru8PrepareTxFrame+0x8>
 a30:	cd b7       	in	r28, 0x3d	; 61
 a32:	de b7       	in	r29, 0x3e	; 62
 a34:	8c 83       	std	Y+4, r24	; 0x04
	uint8_t lu8ChkSum = 0, lu8Loop = 0, lu8TxDLC = 0;
 a36:	19 82       	std	Y+1, r1	; 0x01
 a38:	1a 82       	std	Y+2, r1	; 0x02
 a3a:	1b 82       	std	Y+3, r1	; 0x03
	
	// Prepare frame for Transmission 
	gau8TxBuffer[0] = COMM_SOF;			// SOF
 a3c:	85 e5       	ldi	r24, 0x55	; 85
 a3e:	80 93 96 00 	sts	0x0096, r24
	gau8TxBuffer[1] = lu8TxFrameID;		// Frame ID
 a42:	8c 81       	ldd	r24, Y+4	; 0x04
 a44:	80 93 97 00 	sts	0x0097, r24
	
	// select DLC according to frame ID
	switch(lu8TxFrameID)
 a48:	8c 81       	ldd	r24, Y+4	; 0x04
 a4a:	88 2f       	mov	r24, r24
 a4c:	90 e0       	ldi	r25, 0x00	; 0
 a4e:	85 32       	cpi	r24, 0x25	; 37
 a50:	91 05       	cpc	r25, r1
 a52:	69 f0       	breq	.+26     	; 0xa6e <ru8PrepareTxFrame+0x46>
 a54:	86 32       	cpi	r24, 0x26	; 38
 a56:	91 05       	cpc	r25, r1
 a58:	24 f4       	brge	.+8      	; 0xa62 <ru8PrepareTxFrame+0x3a>
 a5a:	81 32       	cpi	r24, 0x21	; 33
 a5c:	91 05       	cpc	r25, r1
 a5e:	39 f0       	breq	.+14     	; 0xa6e <ru8PrepareTxFrame+0x46>
									break;
		case RESP_QUADRANT		:
									lu8TxDLC = 1;
									break;
									
		default					:	break;									
 a60:	0d c0       	rjmp	.+26     	; 0xa7c <ru8PrepareTxFrame+0x54>
	// Prepare frame for Transmission 
	gau8TxBuffer[0] = COMM_SOF;			// SOF
	gau8TxBuffer[1] = lu8TxFrameID;		// Frame ID
	
	// select DLC according to frame ID
	switch(lu8TxFrameID)
 a62:	87 32       	cpi	r24, 0x27	; 39
 a64:	91 05       	cpc	r25, r1
 a66:	31 f0       	breq	.+12     	; 0xa74 <ru8PrepareTxFrame+0x4c>
 a68:	88 32       	cpi	r24, 0x28	; 40
 a6a:	91 05       	cpc	r25, r1
 a6c:	31 f4       	brne	.+12     	; 0xa7a <ru8PrepareTxFrame+0x52>
	{
		case RESP_SYS_STATUS	:
		case RESP_PULSE_COUNT	:
		case RESP_DEGREES		: 
									lu8TxDLC = 4;
 a6e:	84 e0       	ldi	r24, 0x04	; 4
 a70:	8b 83       	std	Y+3, r24	; 0x03
									break;
 a72:	04 c0       	rjmp	.+8      	; 0xa7c <ru8PrepareTxFrame+0x54>
		case RESP_QUADRANT		:
									lu8TxDLC = 1;
 a74:	81 e0       	ldi	r24, 0x01	; 1
 a76:	8b 83       	std	Y+3, r24	; 0x03
									break;
 a78:	01 c0       	rjmp	.+2      	; 0xa7c <ru8PrepareTxFrame+0x54>
									
		default					:	break;									
 a7a:	00 00       	nop
	}
	
	gau8TxBuffer[2] = lu8TxDLC;			// DLC
 a7c:	8b 81       	ldd	r24, Y+3	; 0x03
 a7e:	80 93 98 00 	sts	0x0098, r24

	// Data fields
	switch(lu8TxFrameID)
 a82:	8c 81       	ldd	r24, Y+4	; 0x04
 a84:	88 2f       	mov	r24, r24
 a86:	90 e0       	ldi	r25, 0x00	; 0
 a88:	85 32       	cpi	r24, 0x25	; 37
 a8a:	91 05       	cpc	r25, r1
 a8c:	b1 f1       	breq	.+108    	; 0xafa <ru8PrepareTxFrame+0xd2>
 a8e:	86 32       	cpi	r24, 0x26	; 38
 a90:	91 05       	cpc	r25, r1
 a92:	24 f4       	brge	.+8      	; 0xa9c <ru8PrepareTxFrame+0x74>
 a94:	81 32       	cpi	r24, 0x21	; 33
 a96:	91 05       	cpc	r25, r1
 a98:	51 f0       	breq	.+20     	; 0xaae <ru8PrepareTxFrame+0x86>
						gau8TxBuffer[5] = (gu16DegreesElapsedH & 0xFF00) >> 8;								// D1 - H pulse elapsed - MSB
						gau8TxBuffer[6] = (gu16DegreesElapsedH & 0x00FF) >> 0;								// D0 - H pulse elapsed - LSB

						break;
						
		default		:	break;
 a9a:	6e c0       	rjmp	.+220    	; 0xb78 <ru8PrepareTxFrame+0x150>
	}
	
	gau8TxBuffer[2] = lu8TxDLC;			// DLC

	// Data fields
	switch(lu8TxFrameID)
 a9c:	87 32       	cpi	r24, 0x27	; 39
 a9e:	91 05       	cpc	r25, r1
 aa0:	09 f4       	brne	.+2      	; 0xaa4 <ru8PrepareTxFrame+0x7c>
 aa2:	48 c0       	rjmp	.+144    	; 0xb34 <ru8PrepareTxFrame+0x10c>
 aa4:	88 32       	cpi	r24, 0x28	; 40
 aa6:	91 05       	cpc	r25, r1
 aa8:	09 f4       	brne	.+2      	; 0xaac <ru8PrepareTxFrame+0x84>
 aaa:	49 c0       	rjmp	.+146    	; 0xb3e <ru8PrepareTxFrame+0x116>
						gau8TxBuffer[5] = (gu16DegreesElapsedH & 0xFF00) >> 8;								// D1 - H pulse elapsed - MSB
						gau8TxBuffer[6] = (gu16DegreesElapsedH & 0x00FF) >> 0;								// D0 - H pulse elapsed - LSB

						break;
						
		default		:	break;
 aac:	65 c0       	rjmp	.+202    	; 0xb78 <ru8PrepareTxFrame+0x150>

	// Data fields
	switch(lu8TxFrameID)
	{
		case RESP_SYS_STATUS	:		// System status													// DLC - 4
						gau8TxBuffer[3] = gu8ReqDirectionH | ((gu8ReqDirectionV & 0x0F) << 4);				// D3 - Direction : V and H
 aae:	80 91 6c 00 	lds	r24, 0x006C
 ab2:	88 2f       	mov	r24, r24
 ab4:	90 e0       	ldi	r25, 0x00	; 0
 ab6:	82 95       	swap	r24
 ab8:	92 95       	swap	r25
 aba:	90 7f       	andi	r25, 0xF0	; 240
 abc:	98 27       	eor	r25, r24
 abe:	80 7f       	andi	r24, 0xF0	; 240
 ac0:	98 27       	eor	r25, r24
 ac2:	98 2f       	mov	r25, r24
 ac4:	80 91 6b 00 	lds	r24, 0x006B
 ac8:	89 2b       	or	r24, r25
 aca:	80 93 99 00 	sts	0x0099, r24
						gau8TxBuffer[4] = 0x00;																// D2 - reserved
 ace:	10 92 9a 00 	sts	0x009A, r1
						gau8TxBuffer[5] = gu8ReqSpeedRef;													// D1 - Speed divider
 ad2:	80 91 69 00 	lds	r24, 0x0069
 ad6:	80 93 9b 00 	sts	0x009B, r24
						gau8TxBuffer[6] = (gu8ReqStart	& 0x01) |											// D0.0 - Status
 ada:	80 91 68 00 	lds	r24, 0x0068
 ade:	28 2f       	mov	r18, r24
 ae0:	21 70       	andi	r18, 0x01	; 1
										 ((gu8ReqMode	& 0x01) << 1);										// D0.1 - Mode
 ae2:	80 91 6a 00 	lds	r24, 0x006A
 ae6:	88 2f       	mov	r24, r24
 ae8:	90 e0       	ldi	r25, 0x00	; 0
 aea:	81 70       	andi	r24, 0x01	; 1
 aec:	90 70       	andi	r25, 0x00	; 0
 aee:	88 0f       	add	r24, r24
 af0:	99 1f       	adc	r25, r25
	{
		case RESP_SYS_STATUS	:		// System status													// DLC - 4
						gau8TxBuffer[3] = gu8ReqDirectionH | ((gu8ReqDirectionV & 0x0F) << 4);				// D3 - Direction : V and H
						gau8TxBuffer[4] = 0x00;																// D2 - reserved
						gau8TxBuffer[5] = gu8ReqSpeedRef;													// D1 - Speed divider
						gau8TxBuffer[6] = (gu8ReqStart	& 0x01) |											// D0.0 - Status
 af2:	82 2b       	or	r24, r18
 af4:	80 93 9c 00 	sts	0x009C, r24
										 ((gu8ReqMode	& 0x01) << 1);										// D0.1 - Mode
						
						
						break;
 af8:	3f c0       	rjmp	.+126    	; 0xb78 <ru8PrepareTxFrame+0x150>
						
		case RESP_PULSE_COUNT	:		// pulse elapsed count	- normal mode								// DLC - 4
						gau8TxBuffer[3] = (gu16PulseElapsedV & 0xFF00) >> 8;								// D3 - V pulse elapsed - MSB
 afa:	80 91 78 00 	lds	r24, 0x0078
 afe:	90 91 79 00 	lds	r25, 0x0079
 b02:	89 2f       	mov	r24, r25
 b04:	99 27       	eor	r25, r25
 b06:	80 93 99 00 	sts	0x0099, r24
						gau8TxBuffer[4] = (gu16PulseElapsedV & 0x00FF) >> 0;								// D2 - V pulse elapsed - LSB
 b0a:	80 91 78 00 	lds	r24, 0x0078
 b0e:	90 91 79 00 	lds	r25, 0x0079
 b12:	80 93 9a 00 	sts	0x009A, r24
						gau8TxBuffer[5] = (gu16PulseElapsedH & 0xFF00) >> 8;								// D1 - H pulse elapsed - MSB
 b16:	80 91 76 00 	lds	r24, 0x0076
 b1a:	90 91 77 00 	lds	r25, 0x0077
 b1e:	89 2f       	mov	r24, r25
 b20:	99 27       	eor	r25, r25
 b22:	80 93 9b 00 	sts	0x009B, r24
						gau8TxBuffer[6] = (gu16PulseElapsedH & 0x00FF) >> 0;								// D0 - H pulse elapsed - LSB
 b26:	80 91 76 00 	lds	r24, 0x0076
 b2a:	90 91 77 00 	lds	r25, 0x0077
 b2e:	80 93 9c 00 	sts	0x009C, r24

						break;
 b32:	22 c0       	rjmp	.+68     	; 0xb78 <ru8PrepareTxFrame+0x150>
						
		case RESP_QUADRANT		:		// Select quadrant status											// DLC - 1
						gau8TxBuffer[3] = gu8ReqQuadrantSet;												// D0 - Quadrant selected
 b34:	80 91 60 00 	lds	r24, 0x0060
 b38:	80 93 99 00 	sts	0x0099, r24
						
						break;
 b3c:	1d c0       	rjmp	.+58     	; 0xb78 <ru8PrepareTxFrame+0x150>
												
		case RESP_DEGREES	:		// degrees elapsed count - scan mode									// DLC - 4
						gau8TxBuffer[3] = (gu16DegreesElapsedV & 0xFF00) >> 8;								// D3 - V pulse elapsed - MSB
 b3e:	80 91 7c 00 	lds	r24, 0x007C
 b42:	90 91 7d 00 	lds	r25, 0x007D
 b46:	89 2f       	mov	r24, r25
 b48:	99 27       	eor	r25, r25
 b4a:	80 93 99 00 	sts	0x0099, r24
						gau8TxBuffer[4] = (gu16DegreesElapsedV & 0x00FF) >> 0;								// D2 - V pulse elapsed - LSB
 b4e:	80 91 7c 00 	lds	r24, 0x007C
 b52:	90 91 7d 00 	lds	r25, 0x007D
 b56:	80 93 9a 00 	sts	0x009A, r24
						gau8TxBuffer[5] = (gu16DegreesElapsedH & 0xFF00) >> 8;								// D1 - H pulse elapsed - MSB
 b5a:	80 91 7a 00 	lds	r24, 0x007A
 b5e:	90 91 7b 00 	lds	r25, 0x007B
 b62:	89 2f       	mov	r24, r25
 b64:	99 27       	eor	r25, r25
 b66:	80 93 9b 00 	sts	0x009B, r24
						gau8TxBuffer[6] = (gu16DegreesElapsedH & 0x00FF) >> 0;								// D0 - H pulse elapsed - LSB
 b6a:	80 91 7a 00 	lds	r24, 0x007A
 b6e:	90 91 7b 00 	lds	r25, 0x007B
 b72:	80 93 9c 00 	sts	0x009C, r24

						break;
 b76:	00 00       	nop
		default		:	break;
	}
	

	// Calculate checksum
	for(lu8Loop = 0; lu8Loop < (3 + fsu8TxDLC); lu8Loop++)
 b78:	1a 82       	std	Y+2, r1	; 0x02
 b7a:	0d c0       	rjmp	.+26     	; 0xb96 <ru8PrepareTxFrame+0x16e>
	{
		lu8ChkSum += gau8TxBuffer[lu8Loop];
 b7c:	8a 81       	ldd	r24, Y+2	; 0x02
 b7e:	88 2f       	mov	r24, r24
 b80:	90 e0       	ldi	r25, 0x00	; 0
 b82:	8a 56       	subi	r24, 0x6A	; 106
 b84:	9f 4f       	sbci	r25, 0xFF	; 255
 b86:	fc 01       	movw	r30, r24
 b88:	80 81       	ld	r24, Z
 b8a:	99 81       	ldd	r25, Y+1	; 0x01
 b8c:	89 0f       	add	r24, r25
 b8e:	89 83       	std	Y+1, r24	; 0x01
		default		:	break;
	}
	

	// Calculate checksum
	for(lu8Loop = 0; lu8Loop < (3 + fsu8TxDLC); lu8Loop++)
 b90:	8a 81       	ldd	r24, Y+2	; 0x02
 b92:	8f 5f       	subi	r24, 0xFF	; 255
 b94:	8a 83       	std	Y+2, r24	; 0x02
 b96:	8a 81       	ldd	r24, Y+2	; 0x02
 b98:	28 2f       	mov	r18, r24
 b9a:	30 e0       	ldi	r19, 0x00	; 0
 b9c:	80 91 90 00 	lds	r24, 0x0090
 ba0:	88 2f       	mov	r24, r24
 ba2:	90 e0       	ldi	r25, 0x00	; 0
 ba4:	03 96       	adiw	r24, 0x03	; 3
 ba6:	28 17       	cp	r18, r24
 ba8:	39 07       	cpc	r19, r25
 baa:	44 f3       	brlt	.-48     	; 0xb7c <ru8PrepareTxFrame+0x154>
	{
		lu8ChkSum += gau8TxBuffer[lu8Loop];
	}
	
	gau8TxBuffer[lu8Loop++]	= lu8ChkSum;		// Check-sum
 bac:	8a 81       	ldd	r24, Y+2	; 0x02
 bae:	88 2f       	mov	r24, r24
 bb0:	90 e0       	ldi	r25, 0x00	; 0
 bb2:	8a 56       	subi	r24, 0x6A	; 106
 bb4:	9f 4f       	sbci	r25, 0xFF	; 255
 bb6:	29 81       	ldd	r18, Y+1	; 0x01
 bb8:	fc 01       	movw	r30, r24
 bba:	20 83       	st	Z, r18
 bbc:	8a 81       	ldd	r24, Y+2	; 0x02
 bbe:	8f 5f       	subi	r24, 0xFF	; 255
 bc0:	8a 83       	std	Y+2, r24	; 0x02
	gau8TxBuffer[lu8Loop]	= COMM_EOF;			// EOF
 bc2:	8a 81       	ldd	r24, Y+2	; 0x02
 bc4:	88 2f       	mov	r24, r24
 bc6:	90 e0       	ldi	r25, 0x00	; 0
 bc8:	8a 56       	subi	r24, 0x6A	; 106
 bca:	9f 4f       	sbci	r25, 0xFF	; 255
 bcc:	2a ea       	ldi	r18, 0xAA	; 170
 bce:	fc 01       	movw	r30, r24
 bd0:	20 83       	st	Z, r18
	
	return lu8Loop;
 bd2:	8a 81       	ldd	r24, Y+2	; 0x02
}
 bd4:	0f 90       	pop	r0
 bd6:	0f 90       	pop	r0
 bd8:	0f 90       	pop	r0
 bda:	0f 90       	pop	r0
 bdc:	cf 91       	pop	r28
 bde:	df 91       	pop	r29
 be0:	08 95       	ret

00000be2 <__vector_11>:

ISR(USART_RXC_vect)
{
 be2:	1f 92       	push	r1
 be4:	0f 92       	push	r0
 be6:	0f b6       	in	r0, 0x3f	; 63
 be8:	0f 92       	push	r0
 bea:	11 24       	eor	r1, r1
 bec:	2f 93       	push	r18
 bee:	3f 93       	push	r19
 bf0:	8f 93       	push	r24
 bf2:	9f 93       	push	r25
 bf4:	ef 93       	push	r30
 bf6:	ff 93       	push	r31
 bf8:	df 93       	push	r29
 bfa:	cf 93       	push	r28
 bfc:	cd b7       	in	r28, 0x3d	; 61
 bfe:	de b7       	in	r29, 0x3e	; 62
	/* Write serial RX data in read Buff */
	/* If data received */
	if(UCSRA & (1<<RXC))
 c00:	8b e2       	ldi	r24, 0x2B	; 43
 c02:	90 e0       	ldi	r25, 0x00	; 0
 c04:	fc 01       	movw	r30, r24
 c06:	80 81       	ld	r24, Z
 c08:	88 23       	and	r24, r24
 c0a:	bc f4       	brge	.+46     	; 0xc3a <__vector_11+0x58>
	{
		gau8RxBuffer[gu8RxWritePtr] = UDR;
 c0c:	80 91 83 00 	lds	r24, 0x0083
 c10:	88 2f       	mov	r24, r24
 c12:	90 e0       	ldi	r25, 0x00	; 0
 c14:	2c e2       	ldi	r18, 0x2C	; 44
 c16:	30 e0       	ldi	r19, 0x00	; 0
 c18:	f9 01       	movw	r30, r18
 c1a:	20 81       	ld	r18, Z
 c1c:	8a 55       	subi	r24, 0x5A	; 90
 c1e:	9f 4f       	sbci	r25, 0xFF	; 255
 c20:	fc 01       	movw	r30, r24
 c22:	20 83       	st	Z, r18
		gu8RxWritePtr++;
 c24:	80 91 83 00 	lds	r24, 0x0083
 c28:	8f 5f       	subi	r24, 0xFF	; 255
 c2a:	80 93 83 00 	sts	0x0083, r24
		
		if(gu8RxWritePtr > 15)
 c2e:	80 91 83 00 	lds	r24, 0x0083
 c32:	80 31       	cpi	r24, 0x10	; 16
 c34:	10 f0       	brcs	.+4      	; 0xc3a <__vector_11+0x58>
		{
			gu8RxWritePtr = 0;
 c36:	10 92 83 00 	sts	0x0083, r1
		}
	}
}
 c3a:	cf 91       	pop	r28
 c3c:	df 91       	pop	r29
 c3e:	ff 91       	pop	r31
 c40:	ef 91       	pop	r30
 c42:	9f 91       	pop	r25
 c44:	8f 91       	pop	r24
 c46:	3f 91       	pop	r19
 c48:	2f 91       	pop	r18
 c4a:	0f 90       	pop	r0
 c4c:	0f be       	out	0x3f, r0	; 63
 c4e:	0f 90       	pop	r0
 c50:	1f 90       	pop	r1
 c52:	18 95       	reti

00000c54 <rvTxSerialData>:


// Driver function for serial data Tx
void rvTxSerialData(void)
{
 c54:	df 93       	push	r29
 c56:	cf 93       	push	r28
 c58:	cd b7       	in	r28, 0x3d	; 61
 c5a:	de b7       	in	r29, 0x3e	; 62
	// If data is pending for transmission 
	if(gu8TxPtr < gu8TxPtrTarget)
 c5c:	90 91 84 00 	lds	r25, 0x0084
 c60:	80 91 85 00 	lds	r24, 0x0085
 c64:	98 17       	cp	r25, r24
 c66:	e0 f4       	brcc	.+56     	; 0xca0 <rvTxSerialData+0x4c>
	{
		/* If transmit buffer is empty */
		if(UCSRA & (1<<UDRE))
 c68:	8b e2       	ldi	r24, 0x2B	; 43
 c6a:	90 e0       	ldi	r25, 0x00	; 0
 c6c:	fc 01       	movw	r30, r24
 c6e:	80 81       	ld	r24, Z
 c70:	88 2f       	mov	r24, r24
 c72:	90 e0       	ldi	r25, 0x00	; 0
 c74:	80 72       	andi	r24, 0x20	; 32
 c76:	90 70       	andi	r25, 0x00	; 0
 c78:	00 97       	sbiw	r24, 0x00	; 0
 c7a:	c9 f0       	breq	.+50     	; 0xcae <rvTxSerialData+0x5a>
		{
			/* Put data into buffer, sends the data */
			UDR = gau8TxBuffer[gu8TxPtr];
 c7c:	8c e2       	ldi	r24, 0x2C	; 44
 c7e:	90 e0       	ldi	r25, 0x00	; 0
 c80:	20 91 84 00 	lds	r18, 0x0084
 c84:	22 2f       	mov	r18, r18
 c86:	30 e0       	ldi	r19, 0x00	; 0
 c88:	2a 56       	subi	r18, 0x6A	; 106
 c8a:	3f 4f       	sbci	r19, 0xFF	; 255
 c8c:	f9 01       	movw	r30, r18
 c8e:	20 81       	ld	r18, Z
 c90:	fc 01       	movw	r30, r24
 c92:	20 83       	st	Z, r18
		
			gu8TxPtr++;
 c94:	80 91 84 00 	lds	r24, 0x0084
 c98:	8f 5f       	subi	r24, 0xFF	; 255
 c9a:	80 93 84 00 	sts	0x0084, r24
 c9e:	07 c0       	rjmp	.+14     	; 0xcae <rvTxSerialData+0x5a>
		}
	}
	else
	{
		// Indicate the Tx is complete.
		gu8SerialTxDone = TRUE;
 ca0:	81 e0       	ldi	r24, 0x01	; 1
 ca2:	80 93 62 00 	sts	0x0062, r24
		
		gu8TxPtrTarget = 0;
 ca6:	10 92 85 00 	sts	0x0085, r1
		gu8TxPtr = 0;
 caa:	10 92 84 00 	sts	0x0084, r1
	}
 cae:	cf 91       	pop	r28
 cb0:	df 91       	pop	r29
 cb2:	08 95       	ret

00000cb4 <_exit>:
 cb4:	f8 94       	cli

00000cb6 <__stop_program>:
 cb6:	ff cf       	rjmp	.-2      	; 0xcb6 <__stop_program>
